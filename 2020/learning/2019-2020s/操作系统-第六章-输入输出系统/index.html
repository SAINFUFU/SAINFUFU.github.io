<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="SAIN"><meta name="copyright" content="SAIN"><meta name="generator" content="Hexo 4.2.1"><meta name="theme" content="hexo-theme-yun"><title>操作系统-第六章-输入输出系统 | SAIN</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="none" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.8/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1906232_s69jdalisd.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/dog.png"><link rel="mask-icon" href="/dog.png" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/","title":"云游君的小站","version":"0.9.2","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="操作系统-第六章-输入输出系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-第六章-输入输出系统">
<meta property="og:url" content="http://sainfufu.github.io/2020/learning/2019-2020s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="SAIN">
<meta property="og:description" content="操作系统-第六章-输入输出系统">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://sainfufu.github.io/images/pasted-13.png">
<meta property="og:image" content="http://sainfufu.github.io/images/pasted-14.png">
<meta property="og:image" content="http://sainfufu.github.io/images/pasted-15.png">
<meta property="og:image" content="http://sainfufu.github.io/images/pasted-16.png">
<meta property="og:image" content="http://sainfufu.github.io/images/pasted-17.png">
<meta property="og:image" content="http://sainfufu.github.io/images/pasted-18.png">
<meta property="og:image" content="http://sainfufu.github.io/images/pasted-19.png">
<meta property="og:image" content="http://sainfufu.github.io/images/pasted-20.png">
<meta property="article:published_time" content="2020-05-12T23:32:22.000Z">
<meta property="article:modified_time" content="2020-06-25T08:07:28.000Z">
<meta property="article:author" content="SAIN">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://sainfufu.github.io/images/pasted-13.png"><script src="/js/ui/mode.js"></script><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="SAIN"><img width="96" loading="lazy" src="/avatar.jpg" alt="SAIN"></a><div class="site-author-name"><a href="/about/">SAIN</a></div><a class="site-name" href="/about/site.html">SAIN</a><sub class="site-subtitle">记录怪异</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archives_4px"></use></svg></span><span class="site-state-item-count">140</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-category"></use></svg></span><span class="site-state-item-count">11</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-06Tags"></use></svg></span><span class="site-state-item-count">47</span></a></div><a class="site-state-item hty-icon-button" href="/albums/" title="相册"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-tupianbizhi"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/categories/%E5%AD%A6%E4%B9%A0/" title="学习" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xuexi"></use></svg></a><a class="links-item hty-icon-button" href="/categories/Eng/" title="英语笔记" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-english"></use></svg></a><a class="links-item hty-icon-button" href="/categories/CS/" title="CS" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-technology_computer-"></use></svg></a><a class="links-item hty-icon-button" href="/categories/CTF/" title="CTF" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hacker"></use></svg></a><a class="links-item hty-icon-button" href="/categories/%E6%9D%82%E6%80%9D/" title="杂思" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rijibendiary"></use></svg></a><a class="links-item hty-icon-button" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="读书笔记" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-dushu"></use></svg></a><a class="links-item hty-icon-button" href="/categories/%E8%A7%82%E5%BD%B1%E7%AC%94%E8%AE%B0/" title="观影笔记" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-dianying"></use></svg></a><a class="links-item hty-icon-button" href="/slides/" title="ppt" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ppt"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-系统的功能、模型和接口"><span class="toc-number">1.</span> <span class="toc-text">I&#x2F;O 系统的功能、模型和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O系统的基本功能"><span class="toc-number">1.1.</span> <span class="toc-text">I&#x2F;O系统的基本功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O系统的层次结构和模型"><span class="toc-number">1.2.</span> <span class="toc-text">I&#x2F;O系统的层次结构和模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#层次结构"><span class="toc-number">1.2.1.</span> <span class="toc-text">层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#层次视图"><span class="toc-number">1.2.2.</span> <span class="toc-text">层次视图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O设备和设备控制器"><span class="toc-number">2.</span> <span class="toc-text">I&#x2F;O设备和设备控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O设备"><span class="toc-number">2.1.</span> <span class="toc-text">I&#x2F;O设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类型"><span class="toc-number">2.1.1.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设备与控制器之间的接口"><span class="toc-number">2.1.2.</span> <span class="toc-text">设备与控制器之间的接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设备控制器"><span class="toc-number">2.2.</span> <span class="toc-text">设备控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设备控制器的基本功能"><span class="toc-number">2.2.1.</span> <span class="toc-text">设备控制器的基本功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设备控制器的组成"><span class="toc-number">2.2.2.</span> <span class="toc-text">设备控制器的组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O控制方式"><span class="toc-number">2.3.</span> <span class="toc-text">I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#程序I-O方式"><span class="toc-number">2.3.1.</span> <span class="toc-text">程序I&#x2F;O方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中断方式"><span class="toc-number">2.3.2.</span> <span class="toc-text">中断方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA方式"><span class="toc-number">2.3.3.</span> <span class="toc-text">DMA方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通道方式"><span class="toc-number">2.3.4.</span> <span class="toc-text">通道方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断机构和中断处理程序"><span class="toc-number">3.</span> <span class="toc-text">中断机构和中断处理程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断机构和中断处理程序-1"><span class="toc-number">4.</span> <span class="toc-text">中断机构和中断处理程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设备驱动程序"><span class="toc-number">5.</span> <span class="toc-text">设备驱动程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与设备无关的I-O软件"><span class="toc-number">6.</span> <span class="toc-text">与设备无关的I&#x2F;O软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户层的I-O软件"><span class="toc-number">7.</span> <span class="toc-text">用户层的I&#x2F;O软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用与库函数"><span class="toc-number">7.1.</span> <span class="toc-text">系统调用与库函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#假脱机（SPOOLing）系统"><span class="toc-number">7.2.</span> <span class="toc-text">假脱机（SPOOLing）系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念"><span class="toc-number">7.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组成"><span class="toc-number">7.2.2.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工作原理"><span class="toc-number">7.2.3.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特点"><span class="toc-number">7.2.4.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#假脱机打印机系统"><span class="toc-number">7.2.5.</span> <span class="toc-text">假脱机打印机系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护进程-daemon"><span class="toc-number">7.3.</span> <span class="toc-text">守护进程(daemon)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓冲区管理"><span class="toc-number">8.</span> <span class="toc-text">缓冲区管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲的引入"><span class="toc-number">8.1.</span> <span class="toc-text">缓冲的引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲技术的实现原理"><span class="toc-number">8.2.</span> <span class="toc-text">缓冲技术的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的缓冲技术"><span class="toc-number">8.3.</span> <span class="toc-text">常用的缓冲技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单缓冲"><span class="toc-number">8.3.1.</span> <span class="toc-text">单缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双缓冲"><span class="toc-number">8.3.2.</span> <span class="toc-text">双缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#环形缓冲"><span class="toc-number">8.3.3.</span> <span class="toc-text">环形缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲池"><span class="toc-number">8.3.4.</span> <span class="toc-text">缓冲池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#磁盘存储器的性能和调度"><span class="toc-number">9.</span> <span class="toc-text">磁盘存储器的性能和调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘性能简述"><span class="toc-number">9.1.</span> <span class="toc-text">磁盘性能简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘低级格式化"><span class="toc-number">9.2.</span> <span class="toc-text">磁盘低级格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘分区"><span class="toc-number">9.3.</span> <span class="toc-text">磁盘分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘高级格式化"><span class="toc-number">9.4.</span> <span class="toc-text">磁盘高级格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘类型"><span class="toc-number">9.5.</span> <span class="toc-text">磁盘类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一次访盘请求"><span class="toc-number">9.6.</span> <span class="toc-text">一次访盘请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#磁盘访问时间—寻道时间-T-s"><span class="toc-number">9.6.1.</span> <span class="toc-text">磁盘访问时间—寻道时间$T_s$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#磁盘访问时间–旋转延迟时间-T-r"><span class="toc-number">9.6.2.</span> <span class="toc-text">磁盘访问时间–旋转延迟时间$T_r$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据传输时间-T-t"><span class="toc-number">9.6.3.</span> <span class="toc-text">数据传输时间$T_t$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#磁盘访问时间-T-a"><span class="toc-number">9.6.4.</span> <span class="toc-text">磁盘访问时间$T_a$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#举例"><span class="toc-number">9.6.5.</span> <span class="toc-text">举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#磁盘调度"><span class="toc-number">9.7.</span> <span class="toc-text">磁盘调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#共享磁盘的调度"><span class="toc-number">9.7.1.</span> <span class="toc-text">共享磁盘的调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#先来先服务调度算法-FCFS"><span class="toc-number">9.7.2.</span> <span class="toc-text">先来先服务调度算法(FCFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最短查找时间优先调度算法（SSTF）"><span class="toc-number">9.7.3.</span> <span class="toc-text">最短查找时间优先调度算法（SSTF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#电梯调度算法-SCAN"><span class="toc-number">9.7.4.</span> <span class="toc-text">电梯调度算法(SCAN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单向扫描调度算法（CSCAN）"><span class="toc-number">9.7.5.</span> <span class="toc-text">单向扫描调度算法（CSCAN）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N步扫描"><span class="toc-number">9.7.6.</span> <span class="toc-text">N步扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N步扫描和FSCAN算法"><span class="toc-number">9.7.7.</span> <span class="toc-text">N步扫描和FSCAN算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#思考题"><span class="toc-number">9.7.8.</span> <span class="toc-text">思考题</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://sainfufu.github.io/2020/learning/2019-2020s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="SAIN"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="SAIN"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">操作系统-第六章-输入输出系统</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2020-05-13 07:32:22" itemprop="dateCreated datePublished" datetime="2020-05-13T07:32:22+08:00">2020-05-13</time></div><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E5%AD%A6%E4%B9%A0/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">学习</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/OS/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">OS</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><!--more-->   
<h2 id="I-O-系统的功能、模型和接口"><a href="#I-O-系统的功能、模型和接口" class="headerlink" title="I/O 系统的功能、模型和接口"></a>I/O 系统的功能、模型和接口</h2><ol>
<li>什么是I/O系统 用于实现数据输入、输出及数据存储的系统。   </li>
<li>I/O系统的主要对象<br>I/O设备<br>相应的设备控制器   </li>
<li>I/O系统的主要任务<br>完成用户提出的I/O请求<br>提高I/O速率<br>提高设备的利用率<br>能为更高层的进程方便地使用这些设备提供手段   </li>
</ol>
<h3 id="I-O系统的基本功能"><a href="#I-O系统的基本功能" class="headerlink" title="I/O系统的基本功能"></a>I/O系统的基本功能</h3><ol>
<li>方便用户使用I/O设备<br><strong>隐藏物理设备的细节</strong><br>I/O设备的类型非常多，且彼此间在多方面都有差异.如：接收和产生数据的速度 、传输方向 、粒度 、数据的表示形式及可靠性<br>配置相应的设备控制器<br><strong>与设备的无关性</strong><br>在隐藏物理设备细节的基础上实现<br>用户可以使用抽象的I/O命令 、使用抽象的逻辑设备名来使用设备 、可有效地提高OS的可移植性和易适应性   </li>
<li>提高CPU和I/O设备的利用率<br><strong>提高处理机和I/O设备的利用率</strong><br> 尽可能地让处理机和I/O设备并行操作，以提高它们的利用率<br> 许多I/O设备间是相互独立的，能够并行操作<br> 处理机与设备之间也能并行操作<br> 要求处理机能快速响应用户的I/O请求，使I/O设备尽快地运行起来<br> 尽量减少在每个I/O设备运行时处理机的干预时间<br><strong>对I/O设备进行控制</strong><br>对I/O设备进行控制是驱动程序的功能对I/O设备有四种控制方式：<br>①采用轮询的可编程I/O方式<br>②采用中断的可编程I/O方式<br> 低速设备（打印机、键盘终端等）<br>③直接存储器访问方式<br> 高速设备（磁盘、光盘等）<br>④ I/O通道方式<br> 独立进行而无需CPU的干预   </li>
<li>在共享设备时提供方便<br><strong>确保对设备的正确共享</strong><br>从设备的共享属性上，可将系统中的设备分为如下两类：<br>(1) 独占设备<br> 进程应互斥地访问这类设备<br> 典型的独占设备：打印机、磁带机等<br>(2) 共享设备<br> 允许多个进程同时访问的设备<br> 典型的共享设备：磁盘<br><strong>错误处理</strong><br>大多数的设备都包括了较多的机械和电气部分，运行时容易出现错误和故障。<br>从处理的角度，可将错误分为临时性错误和持久性错误。<br>对于临时性错误，可通过重试操作来纠正，只有在发生了持久性错误时，才需要向上层报告。   </li>
</ol>
<h3 id="I-O系统的层次结构和模型"><a href="#I-O系统的层次结构和模型" class="headerlink" title="I/O系统的层次结构和模型"></a>I/O系统的层次结构和模型</h3><h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p>普遍采用层次式结构的I/O系统<br>每一层都是利用其下层提供的服务，完成输入输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务<br>通常把I/O软件组织成四个层次 ：<br>(1)用户层I/O软件<br>(2)设备独立性软件<br>(3)设备驱动程序<br>(4)中断处理程序<br><img src="/images/pasted-13.png" alt="upload successful" loading="lazy">   </p>
<h4 id="层次视图"><a href="#层次视图" class="headerlink" title="层次视图"></a>层次视图</h4><ol>
<li>I/O系统的上、下接口<br>(1)  I/O系统接口<br><strong>块设备接口</strong><br>块设备管理程序与高层之间的接口<br><strong>流设备（字符设备）接口</strong><br>流设备管理程序与高层之间的接口，又称为字符设备接口<br><strong>网络通信接口</strong><br>提供相应的网络软件和网络通信接口<br>(2) 软件/硬件(RW/HW)接口   </li>
<li>I/O系统的分层<br>与前面所述的I/O软件组织的层次结构相对应，I/O 系统本身也可分为如下三个层次：<br>(1) 中断处理程序<br> 处于I/O系统的底层，直接与硬件进行交互<br>(2) 设备驱动程序<br> 处于I/O系统的次底层，是进程和设备控制器之间的通信程序<br>(3) 设备独立性软件<br> 也称为与设备无关的软件，使I/O软件独立于具体使用的物理设备   </li>
</ol>
<h2 id="I-O设备和设备控制器"><a href="#I-O设备和设备控制器" class="headerlink" title="I/O设备和设备控制器"></a>I/O设备和设备控制器</h2><p>I/O设备组成   </p>
<ol>
<li>机械部件<br> 即设备本身（物理装置）<br>执行I/O操作   </li>
<li>电子部件<br> 即设备控制器或叫适配器<br>执行I/O控制<br>在小型和微型机中，它常采用印刷电路卡插入计算机主板上的总线插槽<br>通过若干接口寄存器或接口缓冲区与CPU通信   </li>
</ol>
<h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol>
<li>按传输速率分类<br>低速设备   键盘、鼠标<br>中速设备   打印机<br>高速设备   磁带机，光盘机   </li>
<li>按使用特性分类<br>I/O设备<br>存储设备   </li>
<li>按设备共享属性分类<br>独占设备<br>共享设备<br>虚拟设备   </li>
<li>按信息交换的单位分类<br>块设备（Block Device）：<br> 设备一次操作的数据传输单位是块<br> 常见设备：磁盘、磁带等<br> 特征：传输速率高；可寻址；DMA方式<br>字符设备（Character Device）：<br> 设备一次操作的数据传输单位是字符<br> 常见设备：键盘、终端、打印机和鼠标等<br> 特征：传输速率低；不可寻址；中断驱动方式   </li>
<li>按设备的固有属性分类<br>独占设备：在一段时间内只能由一个进程（用户）使用的设备，属于临界资源，如打印机、磁带机等<br>共享设备：在一段时间内可由多个进程同时使用的设备，如磁盘<br>虚拟设备：通过虚拟技术将一台独占设备改造为共享设备，供若干进程同时使用   </li>
</ol>
<h4 id="设备与控制器之间的接口"><a href="#设备与控制器之间的接口" class="headerlink" title="设备与控制器之间的接口"></a>设备与控制器之间的接口</h4><p>该接口中有三类信号：<br>1）数据信号：可由设备到控制器，称为输入；由控制器到设备称为输出。<br>2）控制信号：由设备控制器发送给设备，用于规定设备执行读、写或某种操作的信号。<br>3）状态信号：由设备到控制器，指示设备的当前状态。   </p>
<h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>设备控制器是CPU和I/O设备之间的接口，代替CPU控制设备，实现I/O设备和计算机之间的数据交换   </p>
<h4 id="设备控制器的基本功能"><a href="#设备控制器的基本功能" class="headerlink" title="设备控制器的基本功能"></a>设备控制器的基本功能</h4><p>1)接收和识别命令（控制寄存器）<br>  设备控制器将CPU送来的命令写入控制寄存器中，并进行译码。<br>2)数据交换（数据寄存器）<br>3)标识和报告设备的状态（状态寄存器）设备控制器的基本功能<br>4)地址识别（地址译码器）<br>  系统中的每个设备都有自己的地址段，设备接口电路中有多个寄存器，一个寄存器有唯一的一个地址，每个地址为I/O端口，该地址称为I/O端口地址。<br>  设备控制器必须能识别每个设备的地址。<br>5) 数据缓冲（缓冲器）<br>6) 差错控制   </p>
<h4 id="设备控制器的组成"><a href="#设备控制器的组成" class="headerlink" title="设备控制器的组成"></a>设备控制器的组成</h4><ol>
<li>CPU与控制器的接口   </li>
<li>控制器与设备的接口   </li>
<li>I/O逻辑   </li>
</ol>
<p>计算机系统中各部件都是通过总线来连接的。<br>总线是多个功能部件共享的信息传输线。采用总线结构便于部件和设备的扩充，使用统一的总线标准不同设备间互连将更容易实现。<br>总线的性能可用频率、带宽、速率等指标来衡量。   </p>
<h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><p>I/O控制方式指得就是CPU与外设的通信方式。目前在多通道程序设计环境下,I/O操作控制能力已经成为计算机系统综合处理能力的重要构成因素。<br>一般选取衡量I/O控制方式的好坏时应考虑如下因素：   </p>
<ol>
<li>信息传输效率尽量高，以形成大的吞吐量。   </li>
<li>I/O系统资源利用率好，实现资源的均衡使用。   </li>
<li>尽量减少CPU用于进行I/O处理的开销，使CPU效率得以充分发挥。   </li>
</ol>
<p>按照传输控制能力的强弱与速度,以及CPU与外设并行处理程度的不同。<br>常将I/O系统中信息的传输控制方式分为四类:   </p>
<h4 id="程序I-O方式"><a href="#程序I-O方式" class="headerlink" title="程序I/O方式"></a>程序I/O方式</h4><p>CPU在一条启动外设的I/O指令发出后，同时将忙/闲标志置为忙，如果外设的工作没有完成，则标志一直为忙，<br>CPU不断循环检测该标志，直到标志为不忙为止。然后， CPU就将数据寄存器的值取出，主存与外设之间便可以交换一定量的信息。<br>优点:实现简单，控制简单，基本不需额外硬件支持。<br>缺点:使CPU将大量的时间花费在循环等待上，使CPU 效率发挥极差，外设也不能合理利用，整个系统的效率很低。   </p>
<h4 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h4><p>利用中断信号，外设可以将自身操作的状态及时反馈给CPU，这样CPU便可以在发出一条I/O指令后，转去继续完成其他任务。当I/O操作完成后。外设控制器自动向CPU发出中断请求信号。CPU接到I/O中断信号后进行干预，启动I/O中断处理程序执行。<br>优点:<br>在外设进行数据处理时，CPU不必等待，可以继续执行该程序或其他程序。支持多道程序和设备并行操作。<br>缺点:<br>CPU每次处理的数据量少（通常不超过几个字节,由数据寄存器的大小而定），只适于数据传输率较低的设备。设备速度过高的话容易造成中断次数激增导致数据丢失。   </p>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><ol>
<li>特点：<br>①数据传输的基本单位是数据块；<br>②所传送的数据是从设备直接送入内存的，或者相反；<br>③仅在传送数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。   </li>
<li>组成：<br>(1) 数据寄存器DR 。<br>(2)    内存地址寄存器MAR 。<br>(3)    数据计数器DC 。<br>(4)    命令/状态寄存器CR 。   </li>
<li>局限性：<br>（1）DMA方式如果一次需要读多个数据块则需要CPU进行多次中断处理。<br>（2）多个DMA控制器的同时使用会引起内存地址的冲突并使得控制过程进一步复杂。   </li>
</ol>
<h4 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h4><ol>
<li>概念<br>通道是一个独立与CPU的、专门用来管理输入/输出操作的处理机，它控制设备与内存储器直接进行数据交换。<br>通道的指令被称为“通道命令字”，它的条数不多，主要涉及控制、转移、读、写及查询等功能。<br>若干通道命令字构成一个“通道程序”，它规定了设备应执行的各种操作和顺序。<br>在CPU启动通道后，由通道执行通道程序，完成CPU所交给的I/O任务。为了使通道能取到通道程序去执行，必须把存放通道 必须把存放通道程序的内存起址告诉通道。存放这个起始地址的内存固定单元，被称为“通道地址字”。   </li>
<li>通道方式传输数据的步骤   <ul>
<li>进程提出I/O请求后，CPU发start命令，指明I/O操作、设备号和对应的通道。把数据传输的任务交给通道。 发出I/O请求的进程被阻塞，进程调度程序把CPU分配给另一个进程使用。   </li>
<li>通道接收CPU发来的启动命令，调出通道程序执行，设备与CPU并行工作。   </li>
<li>通道执行通道程序中的<strong>通道命令字</strong>，指示设备完成规定的操作，与内存储器进行数据交换。   </li>
<li>数据传输完毕，通道向CPU发出<strong>中断请求</strong>。CPU响应通道提出的中断请求，对这次I/O进行善后处理，把阻塞进程的状态变为就绪，重新参与对CPU的竞争。   </li>
</ul>
</li>
<li>通道特点：<br>通道执行通道程序，向控制器发出命令，并具有向CPU发中断信号的功能<br>一旦CPU发出指令，启动通道，则通道独立于CPU工作<br>指令类型单一<br>通道没有自己的内存，通道程序在主机的内存中，即通道与CPU共享内存   </li>
</ol>
<h2 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h2><h2 id="中断机构和中断处理程序-1"><a href="#中断机构和中断处理程序-1" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h2><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><h2 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I/O软件"></a>与设备无关的I/O软件</h2><h2 id="用户层的I-O软件"><a href="#用户层的I-O软件" class="headerlink" title="用户层的I/O软件"></a>用户层的I/O软件</h2><p>大部分I／O软件都包含在操作系统中<br>但仍有一小部分在用户空间，包括:   </p>
<ul>
<li>与用户程序连接在一起的库函数   </li>
<li>完全运行于内核之外的SPOOLi    g系统   </li>
</ul>
<h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>库函数   </p>
<ul>
<li>C语言、UNIX系统的库函数   </li>
<li>WiN32 API<br>系统调用是应用程序取得OS所有服务的<strong>唯一途径</strong><br>用户程序通过调用对应的<strong>库函数</strong>使用系统调用   </li>
</ul>
<h3 id="假脱机（SPOOLing）系统"><a href="#假脱机（SPOOLing）系统" class="headerlink" title="假脱机（SPOOLing）系统"></a>假脱机（SPOOLing）系统</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>通过多道程序技术将一台物理CPU虚拟为多台逻辑CPU，允许多个用户共享一台主机<br>通过假脱机技术将一台物理I/O设备虚拟为多台逻辑I/O设备，允许多个用户共享一台物理I/O设备<br>SPOOLing技术,也称为虚拟设备技术,多道程序设计系统中处理独占设备的一种方法<br>利用专门的外围控制机，先将低速I/O设备上的数据传送到高速磁盘上<br>利用假脱机技术可把独占设备转变成具有共享特征的虚拟设备，从而提高设备利用率<br>SPOOLing技术是对脱机输入/输出系统的模拟<br>SPOOLing系统建立在通道技术和多道程序技术的基础上，以高速随机外存(通常为磁盘)为后援存储器   </p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>由输入/输出设备和通道、输入井和输出井、输入井和输出井管理程序、假脱机输入程序以及假脱机输出程序等部分组成<br>输入设备是数据的真正来源<br>输出设备是数据的最终到达地点   </p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li>输入井和输出井<br>在磁盘上开辟出来的<br>输入井模拟脱机输入时的磁盘，用于收容I/O设备输入的数据<br>输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据   </li>
<li>输入缓冲区和输出缓冲区<br>在内存中开辟出来的<br>输入缓冲区用于暂存由输入设备传送的数据，之后再传送到输入井<br>输出缓冲区用于暂存从输出井传送的数据，之后再传送到输出设备   </li>
<li>输入进程和输出进程<br>  输入进程（预输入进程），用于模拟脱机输入时的外围控制机，将用户要求的数据从输入设备传送到输入缓冲区，再放到输入井。当CPU需要的时候，直接从输入井将数据读入内存<br>  输出进程（缓输出进程），用于模拟脱机输出时的外围控制机，将用户要求输入的数据从内存传送到输并存放到输出井。当输出设备空闲时，将输出井中的数据经过输出缓冲区输出至输出设备   </li>
<li>井管理程序：用于控制作业与磁盘井之间信息的交换   </li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>提高了I/O的速度<br>对数据执行的I/O操作。已从对低速I/O设备执行的I/O操作演变为对磁盘缓冲区数据的存取，如同脱机输入输出一样，提高了I/O速度，缓和了CPU和低速I/O设备之间速度的不匹配的矛盾   </li>
<li>将独占设备改造为共享设备<br>因为在假脱机打印机系统中，实际上并没有为任何进程分配设备，而只是在磁盘缓冲区中为进程分配了一个空闲盘块和建立了一张I/O请求表   </li>
<li>实现了虚拟设备功能<br>宏观上，对于每一个进程而言，它们认为是自己独占了一个设备，即使实际上是多个进程在同时使用一台独占设备。也可以说，假脱机系统，实现了将独占设备变换为若干台对应的逻辑设备的功能   </li>
</ol>
<h4 id="假脱机打印机系统"><a href="#假脱机打印机系统" class="headerlink" title="假脱机打印机系统"></a>假脱机打印机系统</h4><p>打印机是经常用到的是输出设备，属于独占设备<br>利用假脱机技术将其改造为一台可供多个用户共享的打印设备，从而提高设备的利用率，也方便了用户   </p>
<p>组成   </p>
<ol>
<li>磁盘缓冲区<br>在磁盘上开辟的一个存储空间，用于暂存用户程序的输出数据   </li>
<li>打印缓冲区<br>设置在内存，暂存从磁盘缓冲区送来的数据，以后再传送给打印设备进行打印   </li>
<li>假脱机管理进程和假脱机打印进程<br>假脱机管理进程：为每个要求打印的用户数据建立一个假脱机文件，并把它放入假脱机文件队列<br>假脱机打印进程：依次对假脱机文件队列中的文件进行打印   </li>
</ol>
<h3 id="守护进程-daemon"><a href="#守护进程-daemon" class="headerlink" title="守护进程(daemon)"></a>守护进程(daemon)</h3><p>守护进程是运行在后台的一种特殊进程,它独立于控制终端并且周期性地执行某种任务或循环等待处理某些事件的发生<br>守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机才随之一起停止运行   </p>
<ul>
<li>数据库守护进程   </li>
<li>日志服务进程<br>打印机守护进程   </li>
<li>取消原假脱机管理进程，由打印机守护进程代替   </li>
<li>打印进程将要求打印的文件放在假脱机文件队列中，并唤醒守护进程   </li>
<li>守护进程的任务是按照队列中每个文件的说明执行逐个打印任务，直至全部完成，然后休眠   <h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2>缓冲区是一个存储区域，它可以由专门的硬件寄存器组成.更多的是利用内存作为缓冲区   <h3 id="缓冲的引入"><a href="#缓冲的引入" class="headerlink" title="缓冲的引入"></a>缓冲的引入</h3></li>
</ul>
<ol>
<li>缓和CPU与I/O设备间速度不匹配的矛盾   </li>
<li>减少对CPU的中断频率，放宽对中断响应时间的限制   </li>
<li>解决数据粒度不匹配的问题<br>可用于解决在生产者和消费者之间交换的数据粒度(数据单元大小)不匹配的问題   </li>
<li>提高CPU和I/O设备之间的并行性<br>在CPU(生产者)和打印机(消费者)之间设置缓冲区后，使CPU与打印机处于并行工作状态   </li>
</ol>
<h3 id="缓冲技术的实现原理"><a href="#缓冲技术的实现原理" class="headerlink" title="缓冲技术的实现原理"></a>缓冲技术的实现原理</h3><p>当某个进程进行数据输出操作时，先将数据送入缓冲区，当缓冲区满时再将缓冲区的内容送到输出设备上<br>当一个进程完成输入操作时，先将输入设备上的数据送入缓冲区，当缓冲区满时，再由CPU将数据取走<br>在缓冲管理中必须建立缓冲区，有两种设定方式   </p>
<ul>
<li>采用硬件方法实现缓冲   </li>
<li>采用软件缓冲的方式，即从主存空间中划定出一个特殊的内存区域作为缓冲区   </li>
</ul>
<h3 id="常用的缓冲技术"><a href="#常用的缓冲技术" class="headerlink" title="常用的缓冲技术"></a>常用的缓冲技术</h3><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>当用户进程发出I/O请求时，操作系统在主存的系统空间为之分配一个缓冲区<br>可以实现预读和滞后写<br>从磁盘把一块数据输入到缓冲区的时间：T<br>OS将该缓冲区中的数据传送到用户区的时间：M<br>CPU对这一块数据处理(计算) 的时间：C<br>T和C可以并行工作<br>当T&gt;C时，系统对每一块数据的处理时间为：M+T<br>当T&lt;\C时，系统对每一块数据的处理时间为：M+C<br>可把系统对每一块数据的处理时间表示为：Max(C，T)+M   </p>
<h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>也称为缓冲对换<br>首先输入将数据送入BUF1，装满后，转向BUF2<br>可以实现用户数据区—缓冲区之间交换数据和缓冲区—外设之间交换数据的并行<br>在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区<br>此时操作系统可以从第一缓冲区中移出数据，并送入用户进程<br>接着由CPU对数据进行计算<br>在双缓冲时，系统处理一块数据的时间可以粗略地认为是Max(C，T)<br>如果C&lt;\T，可使块设备连续输入<br>如果C&gt;T，可使CPU不必等待设备输入   </p>
<h4 id="环形缓冲"><a href="#环形缓冲" class="headerlink" title="环形缓冲"></a>环形缓冲</h4><p>要真正实现CPU与外设的并行操作，双缓冲技术还不能达到要求，在计算机中都采用多缓冲或缓冲池结构<br>为了便于管理，一般将多缓冲组织成循环缓冲形式，每个缓冲区的大小相同   </p>
<p><strong>组成（三类缓冲区）</strong>   </p>
<ol>
<li>空缓冲区R       用于存放数据      指针：Nexti   </li>
<li>已装满数据的缓冲区G  数据供进程使用    指针：Nextg   </li>
<li>现行工作缓冲区C    当前进程使用的缓冲区  指针：Current   </li>
</ol>
<p><strong>Getbuf过程</strong><br>计算进程要取数据： 将指针Nextg所指的缓冲区提供给进程使用，用Current指针指向该缓冲区的第一个单元，同时将Nextg移向下一个G缓冲区。<br>输入进程要使用空缓冲区装数据：将指针Nexti所指的缓冲区提供给输入进程使用，同时将Nexti移向下一个R缓冲区。   </p>
<p><strong>Releasebuf过程</strong><br>当计算进程把C缓冲区中的数据提取完时，调用该过程释放该缓冲区：将该缓冲区由当前工作缓冲区C改为空缓冲区R。<br>当输入进程将缓冲区装满时：将该缓冲区释放，并改为G缓冲区。   </p>
<p><strong>可能出现的两种情况</strong><br>Nexti指针追上Nextg指针（输入速度&gt;处理速度）：无空缓冲区，输入进程阻塞，称为系统受计算限制。<br>Nextg指针追上Nexti指针（输入速度&lt;处理速度）：无数据可取，计算进程阻塞，称为系统受I/O限制。   </p>
<h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>问题：循环缓冲仅适用于某特定的I/O进程和计算进程，属于专用缓冲。当系统较大时，会有很多这样的循环缓冲，不仅消耗大量内存，而且利用率也不高.<br>解决：公用缓冲池——池中缓冲区可供多个进程共享<br>缓冲池与缓冲区的区别:<br>缓冲区仅仅是一组内存块的链表<br>缓冲池则是包含了ー个管理的数据结构及ー组操作函数的管理机制， 用于管理多个缓冲区。   </p>
<p><strong>组成：</strong>   </p>
<ol>
<li>三个队列<br>空缓队列emq<br>由空闲缓冲区连接而成<br>用F(emq)指针指向队首，L(emq)指向队尾<br>输入队列inq<br>由装满输入数据的缓冲区连接而成<br>用F(inq)指针指向队首，L(inq)指向队尾<br>输出队列outq<br>由装满输出数据的缓冲区连接而成<br>用F(outq)指针指向队首，L(outq)指向队尾   </li>
<li>四个工作缓冲区<br>收容输入数据<br>提取输入数据<br>收容输出数据<br>提取输出数据   </li>
</ol>
<h2 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h2><h3 id="磁盘性能简述"><a href="#磁盘性能简述" class="headerlink" title="磁盘性能简述"></a>磁盘性能简述</h3><p>数据的组织和格式<br>磁盘-&gt;柱面-&gt;磁道-&gt;扇区<br>磁盘驱动器结构<br><img src="/images/pasted-14.png" alt="upload successful" loading="lazy"><br>盘面的数据布局（有8个扇区）<br><img src="/images/pasted-15.png" alt="upload successful" loading="lazy"><br>磁盘存储器<br>A：Track 磁盘磁道（粉红色部分）<br>B：Geometrical sector 几何学中的扇形（紫色部分）<br>C：Track sector 磁盘扇区（玫红色部分）<br>D：Cluster 块/簇（绿色部分）<br><img src="/images/pasted-16.png" alt="upload successful" loading="lazy">   </p>
<p>• 老式磁盘上，不同磁道扇区数相同<br>• 现代磁盘上，不同磁道扇区数不同<br>• 被划分为环带，外层环带的磁道比内层环带的磁道拥有更多的扇区   </p>
<h3 id="磁盘低级格式化"><a href="#磁盘低级格式化" class="headerlink" title="磁盘低级格式化"></a>磁盘低级格式化</h3><ul>
<li>磁盘使用之前，必须由软件进行低级格式化   </li>
<li>每条磁道(Track)含有30个固定大小的扇区(Sectors), 每个扇区容量为600个字节，其中512个字节存放<strong>数据</strong>，其余的用于存放<strong>控制信息</strong>   </li>
</ul>
<p><img src="/images/pasted-17.png" alt="upload successful" loading="lazy">   </p>
<h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><p>在低格之后，要对磁盘进行分区   </p>
<ul>
<li>逻辑上每个分区就象一个独立的磁盘   </li>
<li>如 Pentium Pentium和大多数机器上 和大多数机器上，0扇区包含主引导记录 扇区包含主引导记录，其中存放一些引导代码和末尾的分区表   </li>
<li>分区表给出每个分区的起始扇区和大小   </li>
<li>为了能从硬盘引导，在分区表中必须有一个分区被标记为活动的   </li>
</ul>
<h3 id="磁盘高级格式化"><a href="#磁盘高级格式化" class="headerlink" title="磁盘高级格式化"></a>磁盘高级格式化</h3><p>在真正可以使用磁盘前，还需要对磁盘进行一次高级格式化，即设置   </p>
<ul>
<li>一个引导块   </li>
<li>空闲存储管理   </li>
<li>根目录   </li>
<li>一个空文件系统   </li>
<li>在分区表中标记该分区所使用的文件系统   </li>
</ul>
<h3 id="磁盘类型"><a href="#磁盘类型" class="headerlink" title="磁盘类型"></a>磁盘类型</h3><p>磁盘的类型<br>• 固定头磁盘<br>• 移动头磁盘   </p>
<h3 id="一次访盘请求"><a href="#一次访盘请求" class="headerlink" title="一次访盘请求"></a>一次访盘请求</h3><p>• 读/写，磁盘地址（设备号，柱面号，磁头号，扇区号），内存地址（源地址/目的地址）   </p>
<h4 id="磁盘访问时间—寻道时间-T-s"><a href="#磁盘访问时间—寻道时间-T-s" class="headerlink" title="磁盘访问时间—寻道时间$T_s$"></a>磁盘访问时间—寻道时间$T_s$</h4><p>把磁臂(磁头)移动到指定磁道上所经历的时间<br>$$T_s = m*n+s $$<br>m:常数，n:移动的磁道数，s:磁盘启动时间<br>一般磁盘：m=0.2<br>对高速磁盘：m≤0.l<br>磁臂的启动时间约为：2ms<br>对一般的温盘，其寻道时间将随寻道距离的增大而增加，大体上是：5〜30ms   </p>
<h4 id="磁盘访问时间–旋转延迟时间-T-r"><a href="#磁盘访问时间–旋转延迟时间-T-r" class="headerlink" title="磁盘访问时间–旋转延迟时间$T_r$"></a>磁盘访问时间–旋转延迟时间$T_r$</h4><p>指定扇区移动到磁头下面所经历的时间<br>$$ T_r = \frac{1}{2r} $$<br>r为磁盘转速（通常为：转速/单位时间）<br>一般使用简单的假定测量该值，<br>即使用平均值；将磁盘旋转周期的一半作为旋转延迟的近似值，<br>因此，一般都将磁盘旋转周期的一半定为旋转延迟。   </p>
<h4 id="数据传输时间-T-t"><a href="#数据传输时间-T-t" class="headerlink" title="数据传输时间$T_t$"></a>数据传输时间$T_t$</h4><p>把<strong>数据</strong>从磁盘<strong>读出</strong>或向磁盘<strong>写入</strong>数据所经历的时间<br>大小与毎次所读/写的字节数b和旋转速度有关<br>$$ T_t = \frac{b}{rN}$$<br>b：读写字节数； r：磁盘转速 ； N:一个磁道上的字节数<br>当一次读/写的字节数相当于半条磁道上的字节数时，即N=2×b时：<br>$$ T_t = T_r $$   </p>
<h4 id="磁盘访问时间-T-a"><a href="#磁盘访问时间-T-a" class="headerlink" title="磁盘访问时间$T_a$"></a>磁盘访问时间$T_a$</h4><p>访问时间=寻道时间+旋转时间+传输时间   </p>
<ol>
<li>磁盘接收到读指令后，磁头从当前位置移动到目标磁道位置，所需的时间为寻道时间   </li>
<li>旋转磁盘，定位数据所在的扇区，所需时间为旋转延迟时间   </li>
<li>从磁盘上读取数据，时间为数据传输时间   </li>
</ol>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>设一个磁盘的平均寻道时间为20ms，传输速率是1MB/s，控制器开销是2ms，转速为每分钟5400转。<br>求读写一个512字节的扇区的平均时间？<br><font color="navy">解:<br>$$旋转延迟时间T_r=\frac{1}{2r} = \frac{1}{2*5400/60} =0.0056s=5.6ms\\<br>访问时间T_a = T_s+T_r+T_t = 20ms+5.6ms+((512/1024)/1MB/s)+2ms = 28.1ms$$<br></font>   </p>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>当多个访盘请求在等待时，采用一定的策略，对这些请求的服务顺序调整安排，旨在降低平均磁盘服务时间，达到公平、高效<br>– 公平：一个I/O请求在有限时间内满足<br>– 高效：减少设备机械运动所带来的时间浪费，主要是使磁盘的<strong>平均寻道时间</strong>最短<br>磁盘调度的目标：<br>使磁盘的平均寻道时间最少（即平均寻道长度最短）。   </p>
<h4 id="共享磁盘的调度"><a href="#共享磁盘的调度" class="headerlink" title="共享磁盘的调度"></a>共享磁盘的调度</h4><p>移臂调度<br>要提高磁盘的使用效率，只能在减少查找时间和等待时间上想办法，它们都与I/O在磁盘上的分布位置有关。从减少查找时间着手，就称为磁盘的“移臂调度 ”。<br>旋转调度<br>从减少等待时间着手 从减少等待时间着手，就称为磁盘的“旋转调度”。下面只介绍移臂调度的各种算法。   </p>
<h4 id="先来先服务调度算法-FCFS"><a href="#先来先服务调度算法-FCFS" class="headerlink" title="先来先服务调度算法(FCFS)"></a>先来先服务调度算法(FCFS)</h4><p>基本思想：以I/O请求到达的先后次序作为磁盘调度的顺序。<br>特点：简单、较合理，但未对寻道进行优化<br>举例：<br>示例 现在假定读/写磁头位于53号柱面 开始调度时有若干<br>进程顺序提出对如下柱面的I/O请求：<br>98 183 37 122 14 124 65 67<br><img src="/images/pasted-18.png" alt="upload successful" loading="lazy"><br>总共划过的磁道数=(98-53)+(183-98)+(183-37)+(122-37)+(122-14)+(124-14)+(124-65)+(67-65)=45+85+146+85+108+110+59+2=640   </p>
<h4 id="最短查找时间优先调度算法（SSTF）"><a href="#最短查找时间优先调度算法（SSTF）" class="headerlink" title="最短查找时间优先调度算法（SSTF）"></a>最短查找时间优先调度算法（SSTF）</h4><p>基本思想：把距离磁头当前位置最近的I/O请求作为下一次调度的对象<br>特点：寻道性能比FCFS好，但不能保证寻道时间最短 但不能保证寻道时间最短，且有可能引起某些请求的饥饿。<br>举例：（当前53）98 183 37 122 14 124 65 67<br><img src="/images/pasted-19.png" alt="upload successful" loading="lazy"><br>总共划过的磁道数<br>=(65-53)+(67-65)+(67-37)+(37-14)+(98-14)+(122-98)+(124-122)<br>+(183-124)=12+2+30+23+84+24+2+59=236   </p>
<h4 id="电梯调度算法-SCAN"><a href="#电梯调度算法-SCAN" class="headerlink" title="电梯调度算法(SCAN)"></a>电梯调度算法(SCAN)</h4><p>基本思想：<br>沿着移动臂的移动方向选择距离磁头当前位置最近的I/O请求作为下一次调度的对象。如果该方向上已无I/O请求，则改变方向再做选择。<br>注意，由于电梯调度算法与移动臂的移动方向有关，因此磁臂移动的结果路线应该有两个答案。<br>举例：（当前53）98 183 37 122 14 124 65 67<br>由里往外移动<br>总共划过的磁道数<br>=(53-37)+(37-14)+(65-14)+(67-65)+(98-67)+(122-98)+(124-122)+(183-124)=16+23+51+2+31+24+2+59=208<br>由外往里移动<br>总共划过的磁道数=299   </p>
<h4 id="单向扫描调度算法（CSCAN）"><a href="#单向扫描调度算法（CSCAN）" class="headerlink" title="单向扫描调度算法（CSCAN）"></a>单向扫描调度算法（CSCAN）</h4><p>基本思想：<br>总是从0号柱面开始往里移动磁臂，遇到有I/O请求就进行处理，直到到达最后一个请求柱面。然后移动臂立即带动磁头不做任何服务地快速返回到0号柱面，开始下一次扫描<br>举例：（当前53）98 183 37 122 14 124 65 67<br><img src="/images/pasted-20.png" alt="upload successful" loading="lazy"><br>总共划过的磁道数=350   </p>
<h4 id="N步扫描"><a href="#N步扫描" class="headerlink" title="N步扫描"></a>N步扫描</h4><p>引入目的：避免磁臂粘连<br>将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次处理这些子队列，对每个队列的处理用SCAN方法<br>（注意：N的选取）<br>举例：假设磁盘访问序列为98, 183, 37, 122, 14, 124, 65, 67，新出现访问序列是45, 7, 30，读写头起始位置为53，磁头当前向磁道号增加的方向移动。<br>N步扫描（N=3）<br>» 访问序列：（98，183，37），（ 14，122，124），（67，65，45），(30，7）<br>– 总移动距离=526   </p>
<h4 id="N步扫描和FSCAN算法"><a href="#N步扫描和FSCAN算法" class="headerlink" title="N步扫描和FSCAN算法"></a>N步扫描和FSCAN算法</h4><p>引入目的：避免磁臂粘连<br>FSCAN算法：两个队列，一是当前请求I/O的磁盘请求队列，二是在扫描期间新出现的所有磁盘请求组成的队列。这样，所有新到达的访问请求本次不予访问，留待下次再服务。<br>举例，假设磁盘访问序列为98, 183, 37, 122, 14, 124, 65, 67，新出现访问序列是45, 7, 30，读写头起始位置为53，磁头当前向磁道号增加的方向移动<br>– FSCAN算法<br>» 访问序列 （53，65，67，98，122，124，183，37，14）（7，30，45）<br>» 总移动距离=344   </p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>假定一磁盘由100个柱面，编号位0～99，在完成了磁道43处的请求后，当前正在磁道25处进行请求服务。磁盘请求的柱面按磁盘请求的柱面按38，6，40，2，20，22，10的次序到达，寻道时每移动一个柱面需要10ms，计算以下算法的总寻道时间。<br>（1）FCFS<br>（2）SSTF<br>（3）SCAN<br>（4）CSCAN<br><font color="navy"><br>解：<br>（1）FCFS：<code>(38-25)+(38-6)+(40-6)+(40-2)+(20-2)+(22-2)+22-10)=167;167*10=1670ms</code><br>（2）SSTF：<code>(25-22)+(22-20)+(20-10)+(10-6)+(6-2)+(38-2)+(40-38)=61；61*10=610ms</code><br>（3）SCAN：<br>  由里往外：<code>(25-2)+(40-2)=61;61*10=610ms;</code><br>  由外往里：<code>(40-25)+(40-2)=53;53*10=530ms;</code><br>（4）CSCAN：<code>(40-25)+(40-0)+(22-0)=77;77*10=770ms;</code><br><font color="red">每次都向里移动（数大的地方），结束后回到0处，继续向里动   </p>
</div></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/ACM/%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95/" rel="prev" title="随机化算法"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">随机化算法</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/ACM/memset/" rel="next" title="memset的使用"><span class="post-nav-text">memset的使用</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> SAIN</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div id="local-search-result"></div></div></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>