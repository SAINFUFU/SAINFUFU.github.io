<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="SAIN"><meta name="copyright" content="SAIN"><meta name="generator" content="Hexo 4.2.1"><meta name="theme" content="hexo-theme-yun"><title>软件需求工程 | SAIN</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="none" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.8/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1906232_s69jdalisd.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/dog.png"><link rel="mask-icon" href="/dog.png" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/","title":"云游君的小站","version":"0.9.2","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="软件需求工程">
<meta property="og:type" content="article">
<meta property="og:title" content="软件需求工程">
<meta property="og:url" content="http://sainfufu.github.io/2020/learning/2019-2020s/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/index.html">
<meta property="og:site_name" content="SAIN">
<meta property="og:description" content="软件需求工程">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://sainfufu.github.io/images/rjgc1.png">
<meta property="article:published_time" content="2020-05-07T14:11:46.000Z">
<meta property="article:modified_time" content="2020-06-25T08:07:28.000Z">
<meta property="article:author" content="SAIN">
<meta property="article:tag" content="软件需求工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://sainfufu.github.io/images/rjgc1.png"><script src="/js/ui/mode.js"></script><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="SAIN"><img width="96" loading="lazy" src="/avatar.jpg" alt="SAIN"></a><div class="site-author-name"><a href="/about/">SAIN</a></div><a class="site-name" href="/about/site.html">SAIN</a><sub class="site-subtitle">记录怪异</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archives_4px"></use></svg></span><span class="site-state-item-count">140</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-category"></use></svg></span><span class="site-state-item-count">11</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-06Tags"></use></svg></span><span class="site-state-item-count">47</span></a></div><a class="site-state-item hty-icon-button" href="/albums/" title="相册"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-tupianbizhi"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/categories/%E5%AD%A6%E4%B9%A0/" title="学习" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-xuexi"></use></svg></a><a class="links-item hty-icon-button" href="/categories/Eng/" title="英语笔记" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-english"></use></svg></a><a class="links-item hty-icon-button" href="/categories/CS/" title="CS" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-technology_computer-"></use></svg></a><a class="links-item hty-icon-button" href="/categories/CTF/" title="CTF" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hacker"></use></svg></a><a class="links-item hty-icon-button" href="/categories/%E6%9D%82%E6%80%9D/" title="杂思" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rijibendiary"></use></svg></a><a class="links-item hty-icon-button" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="读书笔记" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-dushu"></use></svg></a><a class="links-item hty-icon-button" href="/categories/%E8%A7%82%E5%BD%B1%E7%AC%94%E8%AE%B0/" title="观影笔记" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-dianying"></use></svg></a><a class="links-item hty-icon-button" href="/slides/" title="ppt" style="color:doodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ppt"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空"><span class="toc-number">1.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断"><span class="toc-number">1.2.</span> <span class="toc-text">判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答"><span class="toc-number">1.3.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#软件工程与需求工程"><span class="toc-number">2.</span> <span class="toc-text">软件工程与需求工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-1"><span class="toc-number">2.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断-1"><span class="toc-number">2.2.</span> <span class="toc-text">判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-1"><span class="toc-number">2.3.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#需求获取"><span class="toc-number">3.</span> <span class="toc-text">需求获取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-2"><span class="toc-number">3.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断-2"><span class="toc-number">3.2.</span> <span class="toc-text">判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-2"><span class="toc-number">3.3.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#需求分析"><span class="toc-number">4.</span> <span class="toc-text">需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-3"><span class="toc-number">4.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-3"><span class="toc-number">4.2.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构化分析方法"><span class="toc-number">5.</span> <span class="toc-text">结构化分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-4"><span class="toc-number">5.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-4"><span class="toc-number">5.2.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象分析方法"><span class="toc-number">6.</span> <span class="toc-text">面向对象分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-5"><span class="toc-number">6.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-5"><span class="toc-number">6.2.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#需求定义"><span class="toc-number">7.</span> <span class="toc-text">需求定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-6"><span class="toc-number">7.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断-3"><span class="toc-number">7.2.</span> <span class="toc-text">判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-6"><span class="toc-number">7.3.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#形式化描述语言"><span class="toc-number">8.</span> <span class="toc-text">形式化描述语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-7"><span class="toc-number">8.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-7"><span class="toc-number">8.2.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#需求验证"><span class="toc-number">9.</span> <span class="toc-text">需求验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-8"><span class="toc-number">9.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-8"><span class="toc-number">9.2.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#需求管理"><span class="toc-number">10.</span> <span class="toc-text">需求管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-9"><span class="toc-number">10.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断-4"><span class="toc-number">10.2.</span> <span class="toc-text">判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-9"><span class="toc-number">10.3.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向软件行为和视点的建模技术"><span class="toc-number">11.</span> <span class="toc-text">面向软件行为和视点的建模技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-10"><span class="toc-number">11.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断-5"><span class="toc-number">11.2.</span> <span class="toc-text">判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-10"><span class="toc-number">11.3.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向问题域的需求分析"><span class="toc-number">12.</span> <span class="toc-text">面向问题域的需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-11"><span class="toc-number">12.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断-6"><span class="toc-number">12.2.</span> <span class="toc-text">判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-11"><span class="toc-number">12.3.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向多视点的需求工程"><span class="toc-number">13.</span> <span class="toc-text">面向多视点的需求工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择填空-12"><span class="toc-number">13.1.</span> <span class="toc-text">选择填空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断-7"><span class="toc-number">13.2.</span> <span class="toc-text">判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-12"><span class="toc-number">13.3.</span> <span class="toc-text">简答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#需求工程与软件开发管理"><span class="toc-number">14.</span> <span class="toc-text">需求工程与软件开发管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#选择"><span class="toc-number">14.1.</span> <span class="toc-text">选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断-8"><span class="toc-number">14.2.</span> <span class="toc-text">判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简答-13"><span class="toc-number">14.3.</span> <span class="toc-text">简答</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://sainfufu.github.io/2020/learning/2019-2020s/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="SAIN"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="SAIN"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">软件需求工程</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2020-05-07 22:11:46" itemprop="dateCreated datePublished" datetime="2020-05-07T22:11:46+08:00">2020-05-07</time></div><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E5%AD%A6%E4%B9%A0/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">学习</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">软件需求工程</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><p>题型：单选题10个，填空题10个，判断题10，简答题4个，综合题1个  </p>
<!--more-->  
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="选择填空"><a href="#选择填空" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>软件需求规格说明书的内容不应包括对（算法的详细过程  ）的描述。  </li>
<li>需求分析最终结果是产生（ 需求规格说明书 ）  </li>
<li>需求分析中，开发人员要从用户那里解决的最重要的问题是（ 让软件做什么  ）  </li>
<li>需求规格说明书的作用不应包括（软件可行性研究的依据）  </li>
<li>软件需求分析阶段的工作，可以分成4个方面：需求获取，需求分析，编写需求规格说明书以及（ 需求评审 ）  </li>
<li>需求验证应该从下述几个方面进行验证：（一致性、现实性、完整性、有效性）  </li>
<li>需求分析阶段研究的对象是（用户需求）  </li>
<li>需求分析阶段建立原型的目的是 （ 确定系统是否满足用户需要  ）。  </li>
<li>需求分析的目的是保证需求的（ 完整性和一致性  ）。  </li>
<li>软件开发的需求活动，其主要任务是 （ 定义需求并建立系统模型 ）  </li>
<li>需求分析的步骤：调查研究、分析与综合、书写文档、需求分析评审  </li>
<li>需求分析阶段需编写的文档有需求规格说明书、初步用户使用手册、确认测试计划  </li>
<li>系统规格说明，数据要求，用户系统描述，修正的开发计划 ,这四份文档资料是在书写文档阶段必需完成的。  </li>
<li>软件需求的逻辑视图给出 ！软件要达到的功能和要处理数据之间的关系, 而不是实现的细节。  </li>
<li>优秀的需求规格说明应该具备 7个特性,即完整性、正确性、精确性、可行性、必要性、无歧义和可验证  </li>
<li>需求分析阶段研究的对象是软件项目的用户要求  </li>
<li>需求工程突出工程化的思想，强调以系统化、条理化和可重复化的方法与技术进行与软件需求相关的活动。               </li>
<li>需求是客户行为在问题域内希望看到的效果。  </li>
<li>非功能需求由性能需求与约束与限制构成。  </li>
<li>目标需求限定了项目的范围和项目应达到的目的。  </li>
<li>产品特性可以称为质量属性，在众多质量属性中，对于开发人员来说重要的属性有（可维护性、可移植性、可重用性、可测试性）  </li>
<li>软件开发中，原型是软件的一个早期可运行的版本，它反映最终系统的部分重要特性。其中探索性和实验性用完就可以丢弃，而进化型围绕原型修改和增加。  </li>
<li>常用的动态分析方法不包括（层次方框图），包括（状态迁移图、时序图、petri网）  </li>
</ol>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><ol>
<li>需求工程包括需求获取和需求开发两个方面。x  </li>
<li>需求验证是需求工程中最后一个活动。x  </li>
<li>规格说明是问题域为满足用户需求而提供的解决方案,规定了解系统的行为特征。x  </li>
<li>业务需求具有明显的目的性和较高的抽象性,经过明确和细化的处理,可以直接转化为系统需求。x  </li>
<li>需求开发的一些特性决定了需求开发过程只能是一个简单的线性增量过程。x  </li>
<li>严格意义上的原型主要被用在需求分析阶段。√  </li>
<li>要完成相同的功能,构建抛弃式原型比构建演化式原型所花费的代价要大得多。x  </li>
<li>结构化分析方法适合于数据处理类型软件的需求分析。√  </li>
<li>软件需求描述的是“如何做”，而不是“做什么”。x  </li>
<li>软件需求的层次包括业务需求、用户需求、功能需求。√  </li>
</ol>
<h3 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h3><ol>
<li>简述需求工程的主要任务。<br> 需求工程有以下三个主要任务：  <ol>
<li>需求工程必须说明软件系统将被应用的环境及其目标，说明用来达成这些目标的软件功能，还要说明在设计和实现这些功能时上下文环境对软件完成任务所用方式、方法所施加的限制和约束，也即要同时说明软件需要“做什么”和“为什么”需要做。  </li>
<li>需求工程必须将目标、功能和约束反映到软件系统中，映射为可行的软件行为，并对软件行为进行准确的规格说明。需求规格说明是需求工程最为重要的成果，是项目规划、设计、测试、用户手册编写等很多后继软件开发阶段的工作基础。  </li>
<li>现实世界是不断变化的世界，因此需求工程还需要妥善处理目标、功能和约束随着时间的演化情况。同时，为了节省开支和进行需求规格说明的重用，需求工程还需要对目标、功能和约束在软件产品族中的演化和分布情况进行综合考虑与处理。  </li>
</ol>
</li>
<li>简述常见的需求定义错误。  <ol>
<li>需求并没有反映用户的真实需要。  </li>
<li>模糊和歧义的需求。   </li>
<li>信息遗漏。  </li>
<li>不必要的需求。   </li>
<li>不切实际的期望。  </li>
</ol>
</li>
<li>需求分析阶段需要执行哪些活动？  <ol>
<li>问题分析<br> 对问题进行分析，定义解决方案  </li>
<li>确定系统边界<br> 将所有问题的解决方案进行综合，就可以得到整个解系统的功能和边界  </li>
<li>需求建模<br> 对需求进行建模，完成从问题世界向计算机世界的转换  </li>
<li>需求细化<br> 明确用户需求的隐含信息，展开为明确的对软件系统的行为期望，即系统需求。  </li>
<li>确定需求优先级<br> 对需求进行分级，保证等级更高的需求得到更多的实现保证  </li>
<li>需求协商<br> 检测冲突的存在，并提供信息以帮助和引导协商活动的开展  </li>
</ol>
</li>
<li>需求规格说明书由哪些部分组成？各部分之间的关系是什么？<br> 软件需求说明书一般包括如下内容<br> 1）引言部分编写<br> 目的；项目背景（应包括：a.项目的委托单位、开发单位和主管部门；b．该软件系统与其他系统的关系。）；定义；列出文档中所用到的专门术语的定义和缩写词的原文。）<br> 2）任务概述<br> 目标；运行环境；条件与限制。<br> 3）数据描述<br> 静态数据；动态数据（包括输入数据和输出数据）；数据库描述（给出使用数据库的名称和类型）；数据词典；数据采集。<br> 4）功能要求<br> 功能划分；功能描述。<br> 5）性能需求<br> 数据精确度；时间特性（如响应时间、更新处理时间、数据转换与传输时间、运行时间等）；适应性（在操作方式、运行环境、与其他软件的接囗以及开发计划等发生变化时，应具有的适应能力。）<br> 5）运行需求<br> 用户界面（如屏幕格式、报表格式、菜单格式、输入输出时间等）；硬件接口；软件接口；故障处理。<br> 7）其他要求<br> 如可使用性、安全保密、可维护性、可移植性等。<br> 8）附录  </li>
</ol>
<h2 id="软件工程与需求工程"><a href="#软件工程与需求工程" class="headerlink" title="软件工程与需求工程"></a>软件工程与需求工程</h2><h3 id="选择填空-1"><a href="#选择填空-1" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>（数据流图）用于描述数据的处理过程。  </li>
<li>面向对象技术中，对象是类的实例。对象有三种成分（标识）、属性和方法（或操作）。  </li>
<li>在原型法中，开发人员根据（ 用户 ）的需求不断修改原型，直到满足客户要求为止。  </li>
<li>常用的需求分析方法有：面向数据流的结构化分析方法（SA），面向对象的分析方法（OOA），下列( 快速原型 )不是结构化分析方法的图形工具。  </li>
<li>下列软件开发模型中，（ 螺旋模型 ）只有在开发人员具有风险分析和排除风险的经验及专门知识时，才能获得成功。  </li>
<li>从瀑布模型看，在它的生命周期中的八个阶段中，下面的几个选项中哪个环节出错，对软件的影响最大（需求分析阶段）。  </li>
<li>传统的（ 瀑布模型 ）要求，必须等前一阶段的工作完成之后，才能开始后一阶段的工作；前一阶段的输出文档，就是后一阶段的输入文档。   </li>
<li>需求获取中常见的困难不包括下列哪个( 模型建立 )。  </li>
<li>建立需求基线的作用不包括（ 可以拓展应用 ）。  </li>
<li>软件开发的生命周期包括（ 需求分析 ）、软件设计、代码实现、（  测试  ）、（ 运行 ）、维护，共六个阶段。  </li>
<li>在软件开发中，使用原型时可采取两种不同的策略，即：（ 废弃）策略和（进化  ）策略。  </li>
<li>数据流图和数据字典共同构成了系统的逻辑模型，是需求规格说明书的主要组成部分。  </li>
<li>通常来说,如果用户需求出现了模糊、不清晰、不完整等具有一定不确定性的特征,就可以考虑使用原型法。  </li>
<li>模型语言的三要素：语法、语义、语用。其中语用给出了一个模型元素描述的更宽广的上下文,以及影响该模型元素意义的约束和假定。  </li>
<li>UML行为模型的活动图是依据处理流程进行的用例实现。  </li>
<li>UML行为模型的交互图通常描述的是单个用例的典型场景。  </li>
<li>需求基线的维护主要包括配置管理和状态维护  </li>
<li>风险管理的要素包括（风险评价、风险避免、风险控制）  </li>
</ol>
<h3 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h3><ol>
<li>需求验证并不是一个可以一次结束的活动,它可能需要多次、反复地执行验证。√  </li>
<li>数据流图中每个加工至少有一个输入数据流，但可以没有输出数据流。x  </li>
<li>业务规则包括企业方针、政府条例、工业标准、会计准则和计算方法等。业务规划本身就是软件需求。x  </li>
<li>需求工程包括需求获取和需求开发两个方面。x  </li>
<li>需求开发的一些特性决定了需求开发过程只能是一个简单的线性增量过程。x  </li>
<li>软件需求分析的关键是为真实世界的问题建立模型,即问题域建模。√  </li>
<li>软件成功的标准是用户在用，并且可以很容易做完要做的事。√  </li>
<li>获取需求活动的展开只要保证项目的范围，可以有需求遗漏。x  </li>
<li>在软件生命周期中，工程量最大的阶段就是编写程序。x  </li>
<li>开发人员和客户对软件质量因素的认可是完全一致的。x  </li>
</ol>
<h3 id="简答-1"><a href="#简答-1" class="headerlink" title="简答"></a>简答</h3><ol>
<li>如何有效的处理需求的变化是很多现代软件开发技术的主题，请从需求变更的原因，一般过程以及控制对策等方面谈谈你的看法。<br>①原因：需求变更时不可避免的。因为问题会发生变化，环境也会发生变化，原来的需求基线可能存在某些缺陷以及用户变动，用户对软件的认识变化，相关产品的出现都会产生需求变更的现象。<br> 需求基线就是被明确和固定的需求集合，是项目团队需要在某一特定产品版本中实现的特征和需求的集合。<br> ②一般过程：1.提出变更 2.变更评估 3.实施变更<br> ③控制对策：需求的变化需要控制。<br> 在响应需求变更的过程中，项目团队还要及时准确的维护需求基线，审计变更记录；<br> 要更新需求基线，保证项目涉众可以访问到最新的需求；   </li>
<li>简述软件开发中为何使用原型工具以及使用的好处。<br> 因为原型是在最终系统产生之前的一个局部真实表现,所以原型方法可以让人们在系统 的开发过程中,就能够对一些具体问题进行基于实物的有效沟通,从而帮助人们尽早解决软 件开发过程中存在的各种不确定性。不确定性是指人们已经拥有的知识是不充分的,不足以 预测将来的事件发展,或者不足以清晰、准确地描述某个事物。<br> 好处：<br> ①及时、有力地响应用户需求的变化。<br> ②减少返工。<br> ③帮助控制不完整需求所带来的风险。<br> ④可以将一个大的难以处理的开发过程细分成一些更小更容易处理的步骤。<br> ⑤减少开发成本,提高经济效益。<br> ⑥增加开发者之间的交流,帮助确定技术解决方案的可行性。<br> ⑦有效地识别风险和解决风险,帮助进行风险管理。<br> ⑧提高用户在软件开发中的参与程度。  </li>
</ol>
<h2 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h2><h3 id="选择填空-2"><a href="#选择填空-2" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>用例之间的关系主要有（包含、扩展和泛化）三种。  </li>
<li>项目前景与范围文档中，项目前景不应包括什么信息（  详细的功能需求    ）。  </li>
<li>下列不属于需求开发的活动的是( 需求管理)。  </li>
<li>需求获取的成果（获取笔录、录音或摄像）。  </li>
<li>采用观察方法进行需求获取的原因（事件的情景性）。  </li>
<li>需求跟踪是（需求管理）中的一个活动。  </li>
<li>需求开发计划的基本任务是确定需求开发的实施步骤，给出收集需求活动的具体安排和进度。  </li>
<li>需求获取得到的信息和需求开发应该建立的软件系统解决方案之间有着很大的差距。需求分析就是用来解决这个差距的需求工程活动。  </li>
<li>需求获取是从人、文档或者环境当中获取需求的过程，需求工程师必须要利用各种方法和技术来“发现”需求。  </li>
<li>确定项目目标与范围阶段的基本任务是把项目相关人员定位到一个共同的和明确的方向上，并决定软件系统的范围  </li>
<li>项目的目标主要包括软件开发的目的和意义，以及软件系统应实现的目标（即目标需求）。  </li>
<li>实地调查人员通常分为三步向掌握“全局”的负责人调查、向部门负责人调查以及向业务人员调查进行。  </li>
</ol>
<h3 id="判断-2"><a href="#判断-2" class="headerlink" title="判断"></a>判断</h3><ol>
<li>用例的内容只能包含有正常流程,而不能包含有异常流程。x  </li>
<li>发起或触发用例的外部用户以及其他软件系统等角色被称为参与者。√  </li>
<li>在需求不明确时，若找不到决策者，开发人员可以进行决定。x  </li>
<li>获取需求活动的展开只要保证项目范围，可以有需求遗漏。x  </li>
</ol>
<h3 id="简答-2"><a href="#简答-2" class="headerlink" title="简答"></a>简答</h3><ol>
<li>需求获取分为哪几个阶段？<br> 1、确定需求开发计划；<br> 2、确立项目的目标和范围；<br> 3、确定调查对象；<br> 4、实地收集需求信息；<br> 5、确定非功能需求。  </li>
<li>确定项目范围的好处是？<br> 1、可以判断用户所提出的需求信息是否对项目合适；<br> 2、有些用户需求信息可能是建议，这些建议是项目之外的，但可能有价值，因此可以改变项目范围适应这样的需求，但要考虑对进度、资金的影响。  </li>
<li>调研时通常会遇到怎样一些困难？<br> 1、能提出软件需求的用户可能觉得没有时间与开发人员进行交流和讨论；<br> 2、有时用户希望通过简单的方法与说明，或者通过简单的回答开发人员的询问后，软件开发人员就能清楚理解他们的需求，而不需要花费太多的时间进行讨论；<br> 3、用户和开发人员只考虑自己的利益；<br> 4、用户本身不能提出明确的需求；<br> 5、开发人员没有相关的业务知识。  </li>
<li>按照需求的层次，怎样进行用户分类？<br> 1、提出目标需求的用户；<br> 2、提出业务需求和功能需求的用户；<br> 3、软件开发人员，主要是指系统分析员。  </li>
</ol>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="选择填空-3"><a href="#选择填空-3" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>需求分析的目的是保证需求的（完整性和一致性  ）  </li>
<li>分析的活动主要包括识别、定义和结构化,它的目的是获取某个可以转换为知识的事物的信息,这种分析活动被称为建立需求分析模型  </li>
<li>（抽象和分解）是建模最为常用的两种手段。  </li>
<li>抽象通过强调本质的特征,（减少）了问题的复杂性。  </li>
<li>上下文图描述系统与环境中外部实体之间的界限和联系。它从现实世界的角度说明了系统的（边界和环境）,并确定了所有的输入和输出。  </li>
<li>UML使用的行为模型有三种,即：（交互图、状态图和活动图  ）。  </li>
<li>需求获取得到的信息和需求开发应该建立的软件系统解决方案之间有着很大的差距。需求分析就是用来解决这个差距的需求工程活动。  </li>
<li>需求分析的根本任务是：建立分析模型并创建解决方案。  </li>
<li>建立系统关联图主要是根据需求获取阶段确定的系统范围，用图形表示系统与外部实体间的关联。  </li>
<li>分析需求可行性的基本任务是在允许的成本和性能要求以及系统的范围内，分析每项需求得以实施的可能性。  </li>
<li>需求分析过程应该建立三种模型，他们分别是数据模型、功能模型、行为模型。以下几种图形中，数据流图（DFD）属于功能模型，实体-联系图（ERD）属于数据模型，状态转换图（STD）属于行为模型。  </li>
</ol>
<h3 id="简答-3"><a href="#简答-3" class="headerlink" title="简答"></a>简答</h3><ol>
<li>请说明为何要确定需求的优先级。<br>参考：在理想的情况下,开发者应该让最终的软件系统完美地满足用户提出来的所有需求。但是这种理想的情况并不总是会在现实中发生,甚至是很少在现实中发生。作为一项工程,软件开发总是在一定的环境限制下进行的,成本效益比是它成功的一个基本衡量标准。因此,在工程环境下,需求与需求之间并不是同等重要的,一些需求应该优于另一些需求得到更多在实践中,确定优先级的活动尤为重要的情况有：<br> ①一个项目的资源（时间、人力、成本等）有限,无法满足用户的所有需求。此时项目管理者就需要确定一种最佳方案,在既定的成本下取得最大的效益。需求优先级就是项目管理者进行此项工作的重要基础。<br> ②项目采用了分阶段的开发方式。为了最大化地体现项目的成本效益,项目应该在第一阶段就交付用户最重要和最紧急的需求,并将用户最不重要和最不紧急的需求放在开发的最后一个阶段。这就需要通过确定需求优先级的方式来划分需求的重要性和紧急性等级。<br> ③在项目的开始阶段,并不能明确所有的用户需求,或者无法保证会最终满足所有的用户需求。这个情况是实践中最为常见的情况,迭代式的开发基本都属于这种情况。对这种情况,要区分用户需求的优先级,优先迭代级别高的需求,保证项目最终最大程度地满足了用户的需求。<br> 我的答案：<br> 划分优先级可以①帮助项目相关人员判断系统的核心需求，并有助于项目相关人员集中于重点问题的交流和协商。<br> ②特别是涉及需求风险分析的时候。需求优先级之间的关联可以帮助软件开发人员决定软件体系结构，还可以帮助解决可能发生的设计冲突。<br> ③此外，软件开发人员可以根据需求的优先级权衡合理的项目范围和进度安排、预算、人力资源以及质量目标的要求。<br> ④在需求获取的理想情况下，开发人员应在客户表达需求时由客户决定需求的重要性，标上需求的优先级。然而，如果单独让客户来决定需求的优先级是很难做到的，在众多具有不同期望的用户之间达到一致意见就更难了。因为客户有时总是不能完全理解所提出需求的具体含义，并且每个人的背景、出发点和利益不同，导致他们之间并不总是能产生妥协。<br> ⑤因此，优先级的分配应当由软件开发人员和项目相关人员共同完成，最好是在做了一些初始的分析工作后，再进行需求优先级的分配。<br> ⑥在理想的情况下，开发者应该让最终的软件系统完美地满足用户提出来的所有需求。但是这种理想的情况并不总是会在现实中发生，甚至是很少在现实中发生。作为一项工程，软件开发总是在一定的环境限制下进行的，成本效益比是它成功的一个基本衡量标准。因此，在工程环境下，需求与需求之间并不是同等重要的，一些需求应该优于另一些需求得到更多的实现保证，这就是要确定需求优先级的原因。  </li>
<li>需求分析的具体工作包括：<br> 1.建立系统关联图<br> 2.分析需求的可行性<br> 3.构件用户接口原型<br> 4.确定需求的优先级<br> 5.需求建模<br> 6.建立数据词典  </li>
<li>需求分析<br>需求分析是利用建模与分析技术对获取笔录的内容进行明确、整理、汇总,建立一个综合考虑问题域特性和需求的系统模型,然后根据系统模型将用户需求转化为系统需求的需求工程活动。  </li>
<li>范围（scope）：<br>范围指出当前项目是要解决产品长远规划中的哪一部分,范围声明它为项目划定了需求的界线。  </li>
</ol>
<h2 id="结构化分析方法"><a href="#结构化分析方法" class="headerlink" title="结构化分析方法"></a>结构化分析方法</h2><h3 id="选择填空-4"><a href="#选择填空-4" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>数据建模技术能够弥补过程建模在（ 数据说明 ）方面的缺陷,它描述数据的定义、结构和关系等特性。  </li>
<li>（数据流图DFD）是结构化分析方法的核心技术,它表明系统的输入、处理、存储和输出,以及它们如何在一起协调工作。  </li>
<li>数据流图DFD的基本符号不包括下列哪种（数据字典），包括（加工、外部实体、数据流、数据存储文件）。  </li>
</ol>
<h3 id="简答-4"><a href="#简答-4" class="headerlink" title="简答"></a>简答</h3><ol>
<li>简述使用 DFD描述系统过程模型是必须遵守哪些规则。<br>使用DFD描述系统过程模型是必须遵守一些规则，这些规则可以保证过程模型的正确性。这些规则有：<br> ①过程是对数据的处理，必须有输入，也必须有输出，而且输入数据集和输出数据集应该存在差异。<br> 如果过程在没有输入的情况下产生了输出，称之为“奇迹”，即输出数据在没有任何可见来源的情况下就奇迹般产生了。<br> 如果过程接收了数据输入却没有产生输出，称之为“黑洞”。它浪费了输入的数据资源，却没有做出应有的贡献。<br> 过程是对数据的处理，这种处理是要产生附加价值的，即进行了数据的加工和变换，而不是简单的数据转移。<br> ②数据流是必须和过程产生关联的，它要么是过程的数据输入，要么是过程的数据输出。<br> ③DFD当中所有的对象都应该有一个可以唯一标识自己的名称。过程使用动词，外部实体、数据流和数据存储使用名词。<br> ④将所有软件的输人/输出数据流用一连串加工连接起来。一般可以从输人端逐步到输出端，也可以从输出端逐步到输人端，或者从中间向两端展开。<br> ⑤应集中精力找出数据流。如发现有一-组数据，且用户将其作为一个整体来处理时，则把这组数据作为一个输人流，否则应视为不同的数据流。<br> ⑥在找到数据流后，标识该数据流，然后分析该数据流的组成成分及来去方向，并将其与加工连接。在加工被标识后，再继续寻找其他的数据流。<br> ⑦当加工需要用到共享和暂存数据时，设置文件及其标识。<br> ⑧分析加工的内部，如果加工还比较抽象或其内部还有数据流，则需将该加工进一步分解，直至到达底层图。<br> ⑨为所有的数据流命名。<br> ⑩为所有加工命名编号。编号的方法如下:对于子图的图号，通常是父图中相应被分解加工的编号，加工编号=图号+小数点+局部顺序号。  </li>
<li>请说明 DFD层次结构的建立的主要步骤。<br>DFD层次结构的建立的主要步骤是：<br> ①创建上下文图。<br> ②发现并建立DFD片断。<br> ③根据DFD片断组合产生0层图。<br> ④对0层图的过程进行功能分解,产生N层图。  </li>
</ol>
<h2 id="面向对象分析方法"><a href="#面向对象分析方法" class="headerlink" title="面向对象分析方法"></a>面向对象分析方法</h2><h3 id="选择填空-5"><a href="#选择填空-5" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>ERD中属性是实体的特征,不是数据。属性会以一定的形式存在,这种存在才是数据,被称为属性的（  值 ）。  </li>
<li>面向对象技术中，对象是类的实例。对象有三种成分（标识）、属性和方法（或操作）。  </li>
<li>下列不属于UML 行为模型的是（ 流程图  ）。  </li>
<li>面向对象的分析方法中，主要建立如下三个模型：（对象模型、动态模型、功能模型）  </li>
<li>状态转换图属于（行为模型）。  </li>
<li>OMT方法的基本思想是将面向对象的分析过程视为一个（模型）的构建过程。  </li>
<li>状态是任何可以观察到的（系统行为模式）。  </li>
<li>序列图可用于表达（对象与对象）之间可能发生的所有事件。  </li>
<li>从用户处获得的需求主要有：问题域的范围、目标需求、功能需求、（性能需求）、环境约束与限制等。  </li>
</ol>
<h3 id="简答-5"><a href="#简答-5" class="headerlink" title="简答"></a>简答</h3><ol>
<li>什么是关系的基数或度？<br>关系的基数是衡量关系复杂性的指标之一,又被称为关系的约束。<br> 一个实体在关系中的基数定义了在关系中其他实体实例确定的情况下,该实体实例可能参与关系的数量。<br> 我的答案：<br> 基数表明数据对象在关系上的数量约束<br> 度数是指参与关系的实体数量，是度量关系复杂度的一个指标  </li>
<li>在UML中，表示动态结构的模型有哪些？<br>状态图、活动图、序列图、协作图和配置图等。     </li>
<li>类之间的关系有哪几种？<br> 1.类之间的泛化关系<br> 2.类之间的组成关系<br> 3.对象属性间的静态关系<br> 4.对象行为间的动态关系  </li>
</ol>
<h2 id="需求定义"><a href="#需求定义" class="headerlink" title="需求定义"></a>需求定义</h2><h3 id="选择填空-6"><a href="#选择填空-6" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>下列（律师）不是需求规格说明文档的读者？  </li>
<li>需求规格说明书的作用不应包括（软件可行性研究的依据）  </li>
<li>下列（互操作性）不属于需求规范说明的特性。  </li>
</ol>
<h3 id="判断-3"><a href="#判断-3" class="headerlink" title="判断"></a>判断</h3><ol>
<li>需求规格说明是系统设计与建模的依据。x  </li>
<li>无含糊性要求对所有的需求规格说明只能有一种明确和统一的解释。√  </li>
<li>IEEEStd830标准是我国制定的用于需求规格说明描述的标准。x  </li>
<li>外部接口需求是指与外部软件系统交互的数据格式与规范。x  </li>
<li>人们通常会把用户界面的设计写入需求规格说明文档中。x  </li>
</ol>
<h3 id="简答-6"><a href="#简答-6" class="headerlink" title="简答"></a>简答</h3><ol>
<li>试比较编写需求规格说明文档所使用的三种语言。  <pre><code>需求工程师在描述需求规格说明文档时使用的语言分为三类：  
 ①非形式化语言，即自然语言。  
 ②半形式化语言，比自然语言具有更丰富的语义和更严格的语法同时又没有严格到完全基于数学方法的语言，例如ERD、DFD、UML等图形语言。  
 ③形式化语言，基于数学的语言，例如VDM、Z语言等。  
 自然语言具有复杂的规则和多样化的表达方式，所以它的表达能力最为强大。而且自然语言属于普通人的语言，每个人都熟知其规则、表达方式和特点，所以非常利于用户的理解。但同时自然语言也具有松散、模糊、歧义、凌乱等不好的特性。这使得它无法被机器所理解，它所描述的信息内容也无法准确地映射为机器行为。  
 形式化语言是基于数学方法的语言，具有数学的表示法特性。使用形式化语言描述的信息内容是可以进行逻辑一致性推导和证明的，所以它能够保证信息的正确性。而且形式化的信息描述能够被机器所理解，它所描述的信息内容可以准确地映射为机器行为。但是形式化描述的信息要求读者具备谓词演算方面的知识，这对普通的用户而言显然要求过高，以至于大多数用户无法读懂以形式化方法描述的信息。形式化方法所能描述的内容也是有限的，具体的有限性因形式化方法的不同而各异。  
 半形式化语言是介于自然语言和形式化语言之间的描述语言。一方面，半形式化语言具有严格的语法，定义方式比自然语言更加严格，这使得它可以避免自然语言模糊、松散、歧义、凌乱等不好的特性。另一方面，半形式化语言具有丰富的语义，使用规则比形式化语言更复杂和多样，这使得它具有比形式化方法更强的表达能力。但是，丰富的语义使得半形式化语言的语法无法严格到可以等价于数学方法的程度，所以它描述的信息还需要进行额外的处理才能够被机器所理解或者准确地映射为机器行为。同时，严格的语法限制也使得半形式语言的表达能力无法达到自然语言的程度。而且因为具有独特的语法和语义，所以半形式语言对普通用户而言无异于一门全新的语言，它所描述的信息很难被用户所理解。  
 自然语言采用了以文本为主的描述方式；  
 形式化语言也是使用以文本为主的描述方式；  
 半形式化语言采用了以图形为主的描述方式，  
 因为：  
 ①半形式化语言的语法限制使得它用于信息描述的基本元素是有限的，这个有限性使得它以限定文本或者限定图形符号为描述方式成为可能。  
 ②半形式化语言追求表达语义的丰富性，而在这一点上图形符号是胜过限定文本的，所以人们倾向于选择使用图形符号的描述方式。  
 在进行需求规格说明文档的编写时，用户倾向于使用自然语言，因为其他两种类别的语言难以理解。开发人员倾向于使用半形式语言和形式化语言，因为自然语言的表达不够严格和准确。形式化语言在实践中的应用很少，因为需求规格说明对语言的语义和表达能力有着较高的要求，而这恰恰是形式化语言有所欠缺的。  
 为了让需求规格说明文档的内容能够同时满足用户和开发人员的需要，需求工程师在实践中更多时候会综合使用自然语言、半形式化语言和形式化语言。  </code></pre></li>
<li>请说明为什么要编写需求规格说明文档？<br> （1）编写需求规格说明文档的必要性：<br> 在一个复杂软件系统的开发中，编写需求规格说明文档是非常必要的。<br> 一方面，清晰、明确、结构化的文档可以将软件系统的需求信息和解决方案更好的传递给所有的开发者。另一方面，文档可以拓展人们的知识记忆能力。<br> （2）编写需求规格说明文档的他好处：<br> ①需求规格说明文档可以成为各方人员之间有关软件系统的协议基准。开发者和客户可以使用它作为合同协议的重要部分，涉众也可以利用它在相互间达成一致。<br> ②需求规格说明文档可以成为项目开发活动的一个重要依据。它可以作为软件估算和项目进度安排的基础，也可以作为开发人员判断设计、测试等工作的进行是否正确的依据。<br> ③在需求规格说明文档的编写过程中，可以尽早的发现和减少可能的需求错误，从而减少项目的返工，降低项目的工作量。<br> ④需求规格说明文档可以成为有效的智力资产。这个智力资产可以帮助新加入的团队成员更快的融入项目，可以帮助更好地将软件产品移交给新客户，也可以帮助开发者更好地进行其他类似项目或者后续增强项目的开发。  </li>
<li>编写需求规格说明文档时应该注意一些什么？<br> 1.保持语句和段落的简短，尽量避免将多个需求集中于一个冗长的语句和段落中；<br> 2.最好采用主谓宾的表达方式，并使用正确的语法和标点符号；<br> 3.使用的术语应与词汇表中所定义的一致；<br> 4.为了减少不确定性，必须避免模糊的、主观的术语；<br> 5.避免使用比较性的词汇，应定量地说明所需要提高的程度或者说清一些参数可接受的最大值和最小值；<br> 6.在编写中最好不要出现对某个或某些需求的重复说明；<br> 7.可以把顶层不明确的需求向低层详细分解，直到消除不明确性为止。   </li>
<li>需求规格说明<br>需求规格说明就是将需求及其软件解决方案进行定义和文档化，并传递给开发人员的需求工程活动。  </li>
<li>形式化需求描述语言<br>形式语言是基于数学方法而提出的一种抽象描述语言，该语言具有严格的语法和语义，通常把描述需求的形式语言称为形式化需求描述语言。  </li>
</ol>
<h2 id="形式化描述语言"><a href="#形式化描述语言" class="headerlink" title="形式化描述语言"></a>形式化描述语言</h2><h3 id="选择填空-7"><a href="#选择填空-7" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>描述需求所使用的表示法要符合正规性要求,一般可使用自然语言、结构化语言和形式化语言。在实践中，（自然语言）是主要的描述方式。  </li>
<li>在基于代数的形式化规格说明中，把数据与操作封装为一体的对象称为（抽象数据类型）。  </li>
<li>Z的表示符号主要为数学符号与（图表）符号。  </li>
<li>研究B方法，主要是因为Z语言在（模块化）方面的处理能力不足。  </li>
<li>基于模型的需求形式化描述方法是基于（集合论及一阶谓词）等数学理论的。  </li>
<li>在Z所描述的系统中，系统的状态由一些抽象的（变量）所刻画。  </li>
<li>在LOTOS的模型中，一个系统被看作是一些相互通信的（进程）的集合。  </li>
<li>在B方法中，（抽象机）是最基本的语法描述单元。  </li>
</ol>
<h3 id="简答-7"><a href="#简答-7" class="headerlink" title="简答"></a>简答</h3><ol>
<li>形式化规格说明包括哪几类？<br> 1.基于系统特性的方法；<br> 2.基于模型的方法；<br> 3.基于过程代数的方法。  </li>
<li>简单介绍规格说明的变换过程。<br> 1.制作形式化规格说明<br> 2.验证该规格说明的正确性<br> 3.根据变换规则将现有规格说明变换为另一种规格说明，再证明这两种规格说明再语义上等价<br> 4.重复上述过程的第2、3步，最终获得确保是正确的并可执行的程序  </li>
<li>简单介绍进行抽象数据类型的描述过程。<br> 1.确定所需的全部操作。在这些操作中有生成或更改类的实体操作等；<br> 2.根据各种操作的组合导出公理；<br> 3.补充一些对错误处理的特殊操作，以及追加一些非形式化的说明，以增强代数规格说明的可理解性。  </li>
</ol>
<h2 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h2><h3 id="选择填空-8"><a href="#选择填空-8" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>下面（    验证性）不属于需求验证内容。  </li>
<li>目前验证需求的方法除（形式化方法）外，主要靠人工技术审查和验证软件需求规格说明。  </li>
<li>需求评审就是（ 技术 ）评审，是由非软件开发人员对软件系统的进行检查以发现该系统所存在的问题。  </li>
<li>为需求设计测试用例的目的是确认（需求）而不能确认系统。  </li>
<li>用（自然语言）解释需求模型，有利于评审人员理解和评审需求规格说明。  </li>
<li>软件需求检测和验证理论、技术的发展，是将（可视化技术）与形式化需求验证方法相结合。  </li>
<li>需求验证严格地说就是检验软件需求规格说明  </li>
<li>需求验证非常重要，其能（发现和修复）需求规格说明书存在的问题，并避免在软件系统设计和实现时出现返工。  </li>
<li>需求验证要求各方人员从不同的技术角度对需求规格说明文档做出（综合性）评价。  </li>
<li>需求评审分为（非正式评审），正式评审两类。  </li>
<li>需求评审的工作就是评审（需求规格说明）的内容。  </li>
<li>可视化是指使用图形，图像或者图片等技术，使一些不可见的对象、表达或者抽象概念变成可见的符号。  </li>
</ol>
<h3 id="简答-8"><a href="#简答-8" class="headerlink" title="简答"></a>简答</h3><ol>
<li>需求验证包含哪些活动？<br> 1.软件需求规格证明是否正确描述了目标系统的行为和特征；<br> 2.从其它来源中（包括硬件的系统需求规格说明书）得到软件需求；<br> 3.需求是完整的和高质量的；<br> 4.所有人对需求的看法是一致的；<br> 5.需求为进一步的软件开发和测试提供了足够的基础。  </li>
<li>审查人员由哪些人员组成？<br> 1.从事软件系统需求开发的相关人员；<br> 2.具有编写需求规格说明经验和知识的人员，以及具有评审工作经验的领域专家等；<br> 3.客户或同户代表，他们可以保证需求规格说明能正确地和完整的描述他们的需求；<br> 4.将依据需求规格说明开展工作的软件开发人员，如设计人员，测试人员，项目经理等。  </li>
<li>审查清单可以列举哪些问题？<br> (1)需求是否完整？<br> (2)需求是否一致？<br> (3)需求是否可理解？<br> (4)需求是否明确？<br> (5)需求是否可实现？<br> (6)需求是否可跟踪？<br> (7)需求是否易于修改？<br> (8)需求规格说明文档是否完整？   </li>
<li>需求评审面临的困难有哪些？<br> 1.开发人员最重要的是后面的开发工作，从而导致需求评审成为“走过场” ;<br> 2.需求评审的工作量大；<br> 3.过大的评审小组。  </li>
</ol>
<h2 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h2><h3 id="选择填空-9"><a href="#选择填空-9" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>对所提出的多个变更请求，应由（变更控制委员会）决定实现哪些变更，以及先后次序；  </li>
<li>在版本控制中，每个（版本）的需求规格说明必须是独立说明的，以避免新旧版本的混淆。  </li>
<li>对于未获批准的变更，除进行（可行性论证）外，不应再做其后的工作；  </li>
<li>通过可跟踪信息可以帮助评审和确保所有需求的（可跟踪性）；  </li>
<li>需求管理的主要任务就是开发人员在与提出更改的请求者（用户）协商的基础上，评估需求变更带来的潜在影响及可能的（成本及费用）改变。  </li>
<li>为了便于管理和控制需求变更，可建立一个多个需求变更请求的（状态表），来掌握多个变更请求的实施情况。  </li>
<li>需求跟踪是指编制每个（需求与系统元素）之间联系（即可跟踪信息）的文档。  </li>
<li>对于功能扩展的变更，可以把新扩展系统的视图、（范围）以及限制等文档化，与原有对应文档进行比较，以确定取舍  </li>
</ol>
<h3 id="判断-4"><a href="#判断-4" class="headerlink" title="判断"></a>判断</h3><ol>
<li>需求变更只要处理好功能扩展。x  </li>
<li>在需求变更控制中，应建立所有需求变更要遵循的过程。√  </li>
<li>对于需求变更控制，有时要敢于说不。√  </li>
<li>版本控制需要安排专人修改。√  </li>
</ol>
<h3 id="简答-9"><a href="#简答-9" class="headerlink" title="简答"></a>简答</h3><ol>
<li>需求管理的主要工作内容有哪些？<br> 1）控制对基准需求规格说明的变动；<br> 2）保持项目计划与需求一致；<br> 3）控制单个需求的更改和需求规格说明文档的更改；<br> 4）管理需求和需求间的联系，以及需求与设计和实现等方面的依赖关系；<br> 5）跟踪需求更改的状态，控制多个需求同时更改的复杂性。  </li>
<li>需求变更会带来哪些问题？<br>需求变更通常会带来一系列的问题，如需求间的影响（即当一个需求更改后对其它需求的影响），需求更改对设计和实现的影响等。  </li>
<li>可跟踪信息有哪些类别？<br> (1)需求—源可跟踪性<br> (2)需求—理由可跟踪性<br> (3) 需求—需求可跟踪性<br> (4)需求—体系结构可跟踪性<br> (5)需求—设计可跟踪性<br> (6)需求—用户界面可跟踪性   </li>
<li>变更控制的结束条件有哪些？<br> 1、变更被拒绝、正常处理或中途取消；<br> 2、所有修改后的产品能正常运行；<br> 3、相关的文档已被修改并有新版本要求；<br> 4、有关更改的信息记录到更改库中。  </li>
</ol>
<h2 id="面向软件行为和视点的建模技术"><a href="#面向软件行为和视点的建模技术" class="headerlink" title="面向软件行为和视点的建模技术"></a>面向软件行为和视点的建模技术</h2><h3 id="选择填空-10"><a href="#选择填空-10" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>在视点标识中，需要确定每个视点源对问题子域的（关注点）。  </li>
<li>下列（需求生存周期管理）不属于视点管理内容。  </li>
<li>行为树（图）体现了行为描述语言的（语法结构）。  </li>
<li>研制一个软件系统，正确的方法应该是将问题按先后次序进行（ 分解），然后每一步集中解决某个问题，直至所有问题都被解决。  </li>
</ol>
<h3 id="判断-5"><a href="#判断-5" class="headerlink" title="判断"></a>判断</h3><ol>
<li>软件行为的正确与否决定了软件能否满足用户需求。√  </li>
<li>为获取复杂系统的高质量和可信需求模型，需根据不同的用户视点建立系统的需求模型。√  </li>
<li>行为的主体与客体都必须是确定的。x  </li>
<li>视点检测时，可以从语法的角度检测视点的行为表达式的正确性。√  </li>
</ol>
<h3 id="简答-10"><a href="#简答-10" class="headerlink" title="简答"></a>简答</h3><ol>
<li>划分问题域的具体步骤？<br> （1）开发人员与客户、应用（问题）领域专家等对问题进行交流；<br> （2）确定待开发系统问题域的边界；<br> （3）将系统按照合理的方式划分成多个问题子域；<br> （4）在系统中新建或增添问题子域名。在问题子域名被建立后通常不允许再被修改，否则必须修改所有与该问题子域相关的信息。  </li>
<li>视点生存过程管理内容包括？<br> 1、视点的创建<br> 增加一条视点记录，部分信息槽要系统员输入，一个视点只由一个用户建立并维护。<br> 2、视点的修改<br> 只能由增加者修改，其中包括系统信息与用户信息，分别由管理者与用户修改；<br> 需求描述、场景描述与行为模型具有依赖关系。<br> 3、视点的删除<br> 用户自己删除，并删除相关的信息，记入日志<br> 4、视点的查询<br> 根据权限查询。  </li>
<li>简单介绍研究软件行为的一般方法。<br> （1）如何根据自然语言描述的需求，建立相应场景信息；<br> （2）如何根据场景信息抽取与行为相关的信息，并利用行为描述语言建立行为表达式；<br> （3）如何建立行为描述语言的语义模型，为检验复杂系统的各种特性奠定基础；<br> （4）如何利用模型检验方法和技术检测复杂系统的一些特性。  </li>
<li>视点间关系有哪些？<br> 视点间关系是指两个视点之间在问题域或者需求信息方面的联系。<br> 重叠关系：指两个视点的视点源的观察领域存在一定程度的重合，其包括两种情况：部分重合和完全重合。<br> 顺序关系：指两个视点在行为方面存在着先后关系，如两个视点间存在着传递信息的行为等。<br> 无关系：指两个视点在观察领域上不存在重合，并且不具备行为上的先后关系，如两个并行的视点等。  </li>
<li>复杂系统<br> 复杂系统是一个抽象概念，通常指规模大且内部逻辑关系复杂、涉及相关人员较多的软件系统。  </li>
<li>视点<br> 一个观察者（视点源）根据其关注点和某个问题域而提出的需求信息的集合构成一个视点。  </li>
<li>软件行为<br> 软件的行为是指软件运行时作为主体，依照自身的功能对客体的施用、操作或动作的过程，或主体施用一个服务、操作或动作于客体。<br> 软件的行为由行为主体和客体、操作或动作、行为输入/出和行为属性等组成。  </li>
<li>问题域<br> 所谓问题域是指与问题相关的部分现实世界，问题域和问题相互依存，问题处于一定的问题域之中，脱离了问题域，问题就无法存在。  </li>
</ol>
<h2 id="面向问题域的需求分析"><a href="#面向问题域的需求分析" class="headerlink" title="面向问题域的需求分析"></a>面向问题域的需求分析</h2><h3 id="选择填空-11"><a href="#选择填空-11" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>软件问题的本质是配置的（ 机器 ）M，在相关的域D内，产生了期望的效果R。  </li>
<li>问题域是与问题相关的（ 部分）现实世界。  </li>
<li>并行划分是将每个子问题看成是整个问题的一个（ 投影）。  </li>
<li>问题框架是一种（ 模式 ），它捕获并定义了常见的简单子问题的类型。  <h3 id="判断-6"><a href="#判断-6" class="headerlink" title="判断"></a>判断</h3></li>
<li>信息显示问题框架是要建立一个机器，让该机器从客观世界中获得相关信息，并按所要求的格式呈现在所要求的地方。√  </li>
<li>在PDOA中，采用上下文图来进行问题域的界定。x  </li>
<li>问题图可以描述域与域之间的关系。√  </li>
<li>两个问题框架实例在形式上相互关联是指它们所对应的问题图之间相互关联。√  </li>
</ol>
<h3 id="简答-11"><a href="#简答-11" class="headerlink" title="简答"></a>简答</h3><ol>
<li>简单介绍PDOA方法的分析步骤。  <ol>
<li>搜集需求信息，界定和描述问题及问题域；   </li>
<li>划分问题域并开发相关问题框架；   </li>
<li>根据问题框架的类型进一步描述问题域的相关特性。  </li>
</ol>
</li>
<li>变换问题框架的基本思想是什么？<br>存在一些计算机可读的输入文件，其数据必须被变换以给出所需要的特定输出文件，输出数据必须遵守特定的格式，并且必须按照特定的规则从输入数据中导出。问题是要建立一个机器，该机器从输入中产生所需要的输出。  </li>
<li>问题与问题域之间的相互关系？<br>问题域和问题相互依存，问题处于一定的问题域之中，脱离了问题域，问题就无法存在。问题域也是与特定的问题相关的现实世界，脱离特定的问题考虑纯粹的问题域没有任何意义。  </li>
<li>简单介绍问题域的划分步骤。<br> 1、确定系统所需的各项功能；<br> 2、若某些（或个）功能对应于一个足够小的具体实现单元，则由该实现单元直接实现这些（或个）功能；<br> 3、否则，把功能分解为一系列子功能，并重复步骤2和3，直到所有子功能可分别对应一个足够小的具体实现单元。  </li>
</ol>
<h2 id="面向多视点的需求工程"><a href="#面向多视点的需求工程" class="headerlink" title="面向多视点的需求工程"></a>面向多视点的需求工程</h2><h3 id="选择填空-12"><a href="#选择填空-12" class="headerlink" title="选择填空"></a>选择填空</h3><ol>
<li>（视点 ）是一个形式化的部分规格说明。  </li>
<li>多视点就是在客观分析若干（视点）的内、外部关系的基础上对其进行有机的整理和综合。  </li>
<li>视点标识的主要任务是确定（视点源）；  </li>
<li>（不一致性 ）是群体协作活动中不可避免的一种特性。  </li>
<li>视点的一致性与（ 视点）的表示方法密切相关。  </li>
<li>视点的（集成）是多视点需求工程过程的最后一个阶段。  </li>
<li>视点是服务的（ 接收者 ），这些服务可被看作系统的需求。  </li>
<li>视点间的不一致可以分为（静态约束 ）与动态交互两类。  </li>
</ol>
<h3 id="判断-7"><a href="#判断-7" class="headerlink" title="判断"></a>判断</h3><ol>
<li>视点间关系的类型及性质与视点的标识方法与视点表示方法密切相关。√  </li>
<li>静态约束又分为数据上的约束与结构上的约束。x  </li>
<li>基于规则一致性处理先要定义好视点内部和视点间的一致性规则。√  </li>
<li>如何进行一致性检查和不一致性处理，是视点表示阶段的主要任务。x  </li>
</ol>
<h3 id="简答-12"><a href="#简答-12" class="headerlink" title="简答"></a>简答</h3><ol>
<li>简单介绍面向多视点需求工程的意义。<br>对于大型、复杂软件系统的开发，不可避免的涉及众多项目相关人员，由于各自背景、知识和职责等的不同，不同项目相关人员对目标软件系统可能具自不同的看法和要求，通常，这些看法和要求可能是不全面，不完整的，甚至可能相互矛盾。此外，对于分布式系统或涉及复杂问题领域的系统，由于各项目相关人员方面在地理上可能分布于各处，另一方而可能仅关注整个问题的某个部分，且常以并行的方式提出他们各自的看法和要求。为确保最终开发的软件系统能完整地满足各方面用户的要求。必须在系统开发的早期采用有效的方法来全面地获取不同用户的需求。防止用户重要需求信息的遗漏，同时还必须对不同用户的需求进行系统的检查和分析，发现并协调其中可能存在的不一致，最終形成完整和一致的需求规格说明。  </li>
<li>谈谈面向多视点的需求工程方法的优势。<br> 1、复杂系统的本质特性与多视点思想吻合，利用多视点需求工程方法可以有效地减少某些重要需求被遗漏的可能性，从而保证了需求规约的完备性；<br> 2、每个视点只需关心它自己感兴趣的内容，不需或较少地考虑其它因素的影响，从而有效地降低了需求获取和描述的难度，有利于提高整个需求工程的质量；<br> 3、视点的形式使软件系统以一种更加结构化的形式被描述，从而为自动化的完备性和一致性检查提供了可能性；<br> 4、多视点为封装软件系统的不同描述模型提供了一个强而有力的手段；<br> 5、通过把需求和表达需求的视点关联起来，可增强需求的可追踪性。  </li>
<li>简单介绍常用的视点表示方法。<br> 1、A. Finkelstien采用模板的形式表示每个视点的内容及与其它视点的关系。<br> 2、I.Sommerville在其VORD方法中以框架结构的形式来表示视点。<br> 3、RM-ODP中除声明了五种类型的视点外，也对描述每种类型视点的语言应具有什么样的特征进行了定义。<br> 4、概念图、Z、LOTOS、一阶逻辑等。  </li>
<li>常有的一致性处理方法有？<br> 1、基于规则型:基于预先定义好的视点内部和视点间的一致性规则，以及一致性检查过程模型，这些规则和过程模型由视点模板的设计者根据该模板的用途进行定义。<br> 2、基于逻辑型:用一阶逻辑作为不同规约语言的语义域模型，然后从逻辑的角度定义和检查视点内部及视点间的一致性。<br> 3、基于可实现型:以变换系统作为不同视点规格说明的公共语义模型，由于该变换系统包括静态结构、动态行为及体系结构等多方面的内容，故可作为多种不同类型规约语言的公共语义模型，克服了采用一阶逻辑作为公共语义模型的不足。  </li>
</ol>
<h2 id="需求工程与软件开发管理"><a href="#需求工程与软件开发管理" class="headerlink" title="需求工程与软件开发管理"></a>需求工程与软件开发管理</h2><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><ol>
<li>在用户与软件开发方正式签订的软件开发合同中，大部分估算是依赖（经验 ）而不是依据什么严格的标准和模型而得到的。  </li>
<li>基于软件生命期模型的估算方法（准确性比较差）。  </li>
<li>基于需求的软件规模估算是从（需求规格说明）文档中预估整个软件系统的规模。  </li>
<li>基于需求的工作量估算主要是从需。求中预测代码行、（功能点）或图形界面的数量等估算整个项目的工作量。  </li>
</ol>
<h3 id="判断-8"><a href="#判断-8" class="headerlink" title="判断"></a>判断</h3><ol>
<li>需求工程对软件开发管理影响比较大，但对软件开发过程没有什么影响。x  </li>
<li>在用户与软件开发方正式签订的软件开发合同中，无需进行软件的开发预算和开发进度安排等估算，通常是在需求分析后再进行这些估算。x  </li>
<li>由于对项目的需求与规模不了解，通常在项目规划上会出现问题。√  </li>
<li>在基于需求的软件规模估算中，通常假设软件规模与需求规格说明的规模成正比。√  </li>
</ol>
<h3 id="简答-13"><a href="#简答-13" class="headerlink" title="简答"></a>简答</h3><ol>
<li>简单介绍基于需求的工作量估算方法。<br>对于已知规模的软件，如果令l表示软件规模，N表示开发人数，q表示平均生产效率时，则整个项目的开发时间T为:T=l/(q*N)。<br>如果知道N个人的平均开销的话，则可以由T×N算出该项目的成本。此处，把T×N也称为人月。   </li>
<li>简单介绍开发进度安排出现问题的主要原因。<br> 1)不了解项目的需求与规模。<br> 2)低估了花费的工作量和时间。<br> 3)没有考虑返工，特别是用户需求的变化等因素所需的时间。  </li>
<li>简单介绍基于需求的软件规模估算中，多人估算步骤及方法。<br> 1、首先划分开需求规格说明，例如分为3个部分；<br> 2、由3人分别根据3个部分需求规格说明估算软件的规模；<br> 3、由3人同时根据一部分需求规格说明估算软件的规模；<br> 4、然后得出估算的结果，并估算整个软件的规模。<br> <img src="/images/rjgc1.png" alt="tupian" loading="lazy">  </li>
</ol>
</div></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/ACM/%E7%AE%97m%E7%82%B9%E9%97%AE%E9%A2%98/" rel="prev" title="算m点问题"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">算m点问题</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/CS/hexo%E9%94%99%E8%AF%AF/" rel="next" title="hexo错误"><span class="post-nav-text">hexo错误</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> SAIN</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="Searching..." value=""></div><div id="local-search-result"></div></div></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>